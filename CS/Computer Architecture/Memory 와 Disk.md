# 2023.04.27 데이터베이스 메모리 or 디스크

저장 공간은 크게 휘발성 저장 공간과 비휘발성 저장공간으로 나뉩니다. 

+ **휘발성 저장 공간인 메모리**는 전원 공급이 차단되면 가지고 있는 데이터가 모두 사라지기 때문에, 
데이터베이스는 전원 없이도 데이터를 저장할 수 있는 비휘발성 저장 공간인 디스크(예: SSD, HDD)에 데이터를 저장합니다. 
+ 일반적으로 디스크에 비해 **메모리**는 데이터 전송 속도가 **빠르고** 단위 데이터당 입출력 비용이 낮아서 상대적으로 가격이 **비쌉니다.** 
+ 이 외에도 CD나 자기 테이프와 같은 저장 장치는 가격이 매우 저렴해서 데이터 백업 또는 아카이빙 용도로 많이 사용됩니다.

#### 디스크는 여러 블록으로 구성됩니다. ####

블록은 디스크 I/O 단위입니다. 

+ 블록이 메모리 위의 버퍼에 올라오면 페이지라고 부릅니다. 
+ 디스크에 있는 데이터 묶음은 블록이라고 부르고, 메모리 버퍼 위에 있는 데이터 묶음은 페이지라고 부릅니다.
+ 블록 크기는 보통 4~16KB입니다.
+ 블록 단위로 I/O가 이뤄지기 때문에 블록 크기가 작을 수록 한번에 읽을 수 있는 데이터양이 줄어들지만, 
  + 블록 크기가 크면 내가 필요하지 않는 데이터도 같이 읽어야 하기 때문에 낭비되는 메모리 공간이 생길 수 있습니다. 
  + 만약 블록 크기가 4KB일 때 1KB 파일을 읽으려고 하면 무조건 4KB를 모두 읽어야해서 나머지 3KB의 메모리 버퍼 공간이 낭비될 수 있습니다.
 
    ![Untitled](https://github.com/lielocks/WIL/assets/107406265/5f053434-5556-4732-b757-6c881bf4400b)
- Platter = track + ... + track = Track 50K ~ 100K개 = 12.5 ~ 100GB
- Track = sector + ... + sector = Sector 500 ~ 2000개 = 256KB ~ 1MB
- Sector = 512 bytes
- Head: 데이터를 자기적으로 읽거나 쓰는 장치

### HDD 처리 시간

- Seek time: Head를 특정 track에 위치시키는 시간
- Rotational latency: 특정 sector를 찾기 위해 디스크 원판을 돌리는 시간
- Data transfer time: Head를 통해 자기적으로 저장된 데이터를 읽는 시간

Seek time과 rotational latency는 디스크 헤드의 기계적인 움직임이 필요하기 때문에 상대적으로 시간이 오래 걸리지만, data transfer time은 전기적인 동작이기 때문에 상대적으로 짧습니다.

그리고 만약 동일한 track 위에 데이터를 모아서 저장한다면 해당 데이터에 접근할 때 seek time이 줄어들 수 있어 데이터 전송 속도가 빨라질 수 있습니다.

### **고정 길이**

![Untitled (1)](https://github.com/lielocks/WIL/assets/107406265/1a3affe8-59f0-4052-be49-6ef00bd6493a)


특정 테이블의 레코드 크기는 모두 동일하다고 가정한 경우입니다. 
위 그림과 같이 한 블록의 크기가 4KB라고 가정했을 때 레코드 크기가 100 bytes인 경우 한 블록에 최대 40개의 레코드를 저장할 수 있습니다. 
나머지 96 bytes는 비어있는 공간으로서 굳이 하나의 레코드를 쪼개서 블록을 꽉 채우지 않고 여유공간을 조금 남겨 놓는 것이 나중에 CRUD 작업을 수행할 때 좋다고 합니다.


### **가변 길이**

![Untitled (2)](https://github.com/lielocks/WIL/assets/107406265/90d91b0f-b7fe-4d43-a4d7-8e8c05748e8c)

레코드 안에는 여러 필드가 존재하는데 문자열 자료형의 경우 동일한 테이블의 레코드일지라도 각 필드 길이가 달라질 수 있습니다. 그래서 일반적으론 가변 길이 레코드가 많이 사용됩니다.

가변 길이 레코드는 위 그림과 같이 왼쪽에 고정 길이 필드를 모아 놓고, `varchar`와 같은 가변 길이 필드는 포인터와 데이터 길이로 관리하여 
실제 문자열 데이터는 레코드 오른쪽 부분에 저장합니다.

```sql
CREATE TABLE test (
  id int PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  creation_date timestamptz NOT NULL DEFAULT NOW(),
  name varchar(64) NOT NULL,
  age int NOT NULL,
  address varchar(64) NOT NULL
);

INSERT INTO test (name, age, address) VALUES ('이름이름', 23, '주소주소주소');
```

![Untitled (3)](https://github.com/lielocks/WIL/assets/107406265/5c695b9a-e649-470a-a252-6ff6c3393b52)


예를 들어 위와 같은 구조를 가진 test 테이블에 레코드를 삽입했을 때 해당 레코드의 물리적인 모습은 위 그림과 같습니다. (포인터는 4 bytes로 관리되고 한글은 UTF-8로 처리된다고 가정합니다.)


## 블록 구조

일반적으로 디스크 블록의 크기는 4KB ~ 16KB 입니다.

### 고정 길이 레코드

고정 길이 레코드 방식은 레코드 크기가 모두 동일하기 때문에 레코드를 읽거나 수정하는 작업, 새로운 레코드를 저장하는 과정은 간단합니다. 하지만 레코드 삭제가 까다롭고, nullable 값의 공간 낭비, varchar 같은 문자열 자료형의 관리가 어렵다는 단점이 있습니다.

### 레코드 삭제 방법 1

![Untitled (4)](https://github.com/lielocks/WIL/assets/107406265/e9e9131d-4742-4442-8011-43d281af80fc)

중간에 있는 레코드를 지웠을 때 그 뒤에 있는 레코드를 앞으로 한칸씩 당기는 방식입니다. 
빈 공간이 어디 있는지 찾기 쉽고 남아있는 레코드를 관리하기 수월하지만, 삭제한 레코드 뒤에 있는 모든 레코드를 앞으로 한칸씩 당겨야하기 때문에 해당 레코드를 모두 조회하느라 연산이 많이 발생할 수 있다는 단점이 있습니다.


### 레코드 삭제 방법 2


![Untitled (5)](https://github.com/lielocks/WIL/assets/107406265/2e88b8f4-5905-46ce-9ba9-33ab02a87ea4)


#### I/O 효율화 튜닝의 중요성 ####

- 디스크를 경유한 입출력은 메모리를 통한 입출력보다 평균적으로 10,000배 이상 느립니다.
- 데이터베이스는 하나의 파일 시스템입니다. SQL을 이용하여 데이터 파일에 데이터를 저장하고 출력시 DB 버퍼 캐쉬에 데이터가 없을 경우 디스크를 통하여 데이터를 버퍼 캐쉬에 저장한 후 결과를 줍니다.
- 물리적 디스크 I/O가 필요할 경우 서버 프로세스가 디스크에서 원하는 블록을 가져오고, 같은 데이터를 원할 경우 경합이 발생하여 대기 시간이 길어집니다.

