## 메모리 단편화 Memory Fragmentation
메모리 단편화란 메모리의 공간이 작은 조각으로 나뉘어져 충분히 사용 가능한 메모리가 있음에도 시스템이 메모리 할당을 할 수 없는 상태를 의미합니다.

메모리 단편화가 발행하는 원인에 따라 **`'내부 단편화'`** 와 **`'외부 단편화'`** 로 구분할 수 있습니다.

<br>

### 내부 단편화 Internal Fragmentation
내부 단편화는 필요한 양보다 더 큰 메모리가 할당이 되어서 **할당된 메모리 내부에 사용하지 않는 메모리 공간이 발생한 상황** 을 뜻합니다.

![image](https://github.com/lielocks/WIL/assets/107406265/36d1d541-3ee9-40c7-8bc9-9cae41201616)
위 그림에서와 같이 50KB를 할당 받은 프로세스가 40KB 밖에 사용하지 않는다면 10KB만큼의 내부 단편화가 발생합니다.

예를 들어 메모장을 켰는데 OS가 4kb를 할당해줬다. 그런데 사실상 1kb만큼만 사용하고 있을 때 필요 이상으로 프로세스가 메모리를 할당받았으므로 내부 단편화가 3kb만큼 생긴 것임.

<br>

### 외부 단편화 External Fragmentation
메모리가 할당되고 해제되는 작업이 반복될 때, 작은 메모리가 중간중간 생겨납니다. 
이러한 메모리 공간들이 많아지면서 **총 사용 가능한 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황** 을 외부 단편화라고 합니다.

![image](https://github.com/lielocks/WIL/assets/107406265/87116d86-1bc2-4de7-98ed-634b0b60ae2b)

예를 들어, 처음 메모리에 50KB크기의 프로세스가 할당됩니다. 
이어서 다른 프로세스들이 메모리 공간에 연속적으로 할당됩니다. 
이후, 50KB 프로세스가 종료되면 그 자리에 50KB만큼의 공간이 생깁니다. 
그곳에 다시 40KB크기의 다른 프로세스가 할당되면 10KB만큼의 빈공간이 생깁니다. 

이런 과정이 무수히 반복되면 위 그림과 같이 **작은 크기의 빈공간이 메모리 사이사이에 생기는** 외부 단편화가 발생합니다.

<br>

## 메모리 단편화를 해결하기 위한 메모리 관리 방법

### 1. 페이징 기법 Paging
(가상 메모리 사용, 외부 단편화 해결, 내부 단편화는 여전히 존재)

![image](https://github.com/lielocks/WIL/assets/107406265/19906d92-bbc3-4093-b138-6ce403dbf4b7)

**페이징 기법** 은 고정 분할 방식을 이용한 가상 메모리 관리 기법으로, 물리 주소 공간을 같은 크기의 메모리 영역으로 나누어 사용합니다. 

이때 가상 주소는 프로세스 입장에서 바라본 메모리 공간으로 항상 0번지부터 시작합니다. 
가상 주소의 분할된 각 영역을 **페이지** 라고 하며, 물리 메모리의 각 영역은 **프레임** 이라고 합니다. 
물리 메모리 단위로 가상 메모리를 할당하기 때문에 **`페이지 크기와 프레임 크기는 같습니다.`**

페이지와 프레임을 대응 시키는 과정을 **`page mapping`** 이라고 하며, 이를 위해 **paging table** 이 있습니다. 
페이징 기법을 사용하면 **연속적이지 않은 공간도 활용할 수 있기 때문에 외부 단편화 문제를 해결** 할 수 있습니다. 
대신 **항상 페이지 단위에 맞춰 메모리를 꽉 채워 쓸 수 없으므로 내부 단편화 문제는 여전히 존재** 합니다. 

***(페이지 단위를 작게하면 내부 단편화 문제도 해결할 수 있지만 Page mapping 과정이 많아지므로 오히려 효율이 떨어집니다.)***

<br>

### 2. 세그멘테이션 기법 Segmentation
(가상 메모리 사용, 내부 단편화 해결, 외부 단편화 존재)

![image](https://github.com/lielocks/WIL/assets/107406265/87f74f69-d9fa-4909-b4ba-de81e2047932)

페이징 기법에서 가상 메모리를 일정한 크기의 블록(페이지)로 분할했다면, 세그먼테이션 기법에서는 **가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트** 로 분할해서 메모리 할당을 하고, **실제 메모리 주소로 변환** 합니다.

각 세그먼트는 **`연속적인 공간`** 에 저장되어 있습니다. 
세그먼트들의 `크기가 다르기 때문에` 미리 분할해 둘 수 없고 **메모리에 적재될 때** **`빈 공간을 찾아 할당`** 합니다.

페이지와 마찬가지로 **mapping** 을 위해 **`segment table`** 이 필요합니다. 
table에는 각 세그먼트 항목별로 **세그먼트 시작 주소** 와 **세그먼트의 길이 정보** 를 가지고 있습니다.

프로세스가 요구하는 **`메모리 크기에 맞게 할당`** 하기 때문에 **내부 단편화는 일어나지 않지만** ,
**`중간에 프로세스가 메모리를 해제하면 생기는 구멍`** , 즉 **외부 단편화 문제는 여전히 존재** 합니다.

<br>

### 3. 메모리 풀 Memory Pool
**필요한 메모리 공간** 을 **`적절한 크기, 개수`** 만큼 **사용자가 직접 지정하여 미리 할당받아 필요할 때마다 사용하고 반납** 하는 방법입니다.

`메모리 풀 없이 동적 할당과 해제를 반복하면` 메모리의 랜덤한 (실제로는 알고리즘에 의한) 위치에 할당과 해제가 반복되면서 단편화를 일으킬 수 있겠지만, 
미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 **할당과 해제로 인한 외부 단편화가 발생하지 않습니다.**

또한 **필요한 크기만큼 할당하기 때문에 내부 단편화 또한 생기지 않습니다.**

하지만 메모리 단편화로 인한 메모리 낭비량보다 **메모리 풀을 만들었지만 쓰지 않았을 때 메모리 낭비가 심하므로** **`메모리 할당, 해제가 잦은 경우`** 사용하면 효과적입니다.

**구현 방법**

+ **큰 메모리 블록(페이지)** 을 힙으로부터 할당

+ **할당 받은 페이지** 를 **각 객체의 크기의 블록으로 나눔**

+ 각 객체를 위한 블록을 **순차적으로 링크**

+ 이 때 현 시점에서 할당할 블록을 **특정 포인터** 가 가리키게 함

+ 메모리 요청이 생기면 **현재 헤더 포인터가 가리키는 블록** 을 돌려준다.

+ 할당이 일어난 후 헤더 포인터는 **할당 직전에 가리키던 블록이 가리키던 블록** 을 가리킨다.

+ 사용되던 메모리가 해제되어 메모리 풀로 돌아올 경우 **헤더 포인터는 그 블록** 을 가리키고 **방금 전까지 헤더 포인터가 가리키던 블록을 돌아온 블록의 다음 포인터** 가 가리키게 한다

