# Program 과 Process 의 차이
![image](https://github.com/lielocks/WIL/assets/107406265/d72e478a-cd99-4d6e-b915-ac521669b8bc)

+ **`Program`** : 어떤 작업을 위해 실행할 수 있는 명령어 리스트를 포함하는 파일을 뜻한다.

+ **`Process`** : 운영체제 입장에서 하나의 작업 단위이며, 컴퓨터에서 **연속적으로 실행되고 있는 컴퓨터 프로그램** 을 말한다.

  + **실행파일(program) 이 memory 에 적재되어** _CPU를 할당 받아 실행(연산)되는 것을 Process_ 라고 한다.


<br>


Program 은 일반적으로 Hard Disk 등의 _보조기억장치에 저장된 실행 코드_ 를 뜻하고, 

프로그램을 구동하여 _프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위_ 를 칭한다.

즉, **실행 중인 프로그램** 을 뜻한다.

하나의 프로그램을 여러번 구동하면 여러개의 프로세스가 메모리상에서 실행되는 것이다.


<br>


### Process 의 일반적인 구조

+ Process 는 다음과 같이 4가지 영역으로 나눌 수 있다.

  1. **`Stack`** : 임시 데이터 (함수 호출, 로컬 변수 등) 이 저장되는 영역

  2. **`Heap`** : 코드에서 동적으로 생성되는 데이터가 저장되는 영역

  3. **`Data`** : 전역 변수 / 초기화된 데이터가 저장되는 영역

  4. **`Text (Code)`** : Compile 된 source code 가 저장되는 영역

![image](https://github.com/lielocks/WIL/assets/107406265/605b7714-d004-4980-9c77-355eb9c1a65d)


<br>


### Code 영역

+ Memory 의 Code 영역은 실행할 program 의 코드가 저장되는 영역으로 텍스트(text) 영역이라고도 부릅니다.

+ CPU 는 Code 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.

  
<br>


### Stack 영역

+ Program 이 자동으로 사용하는 Memory 영역으로 함수 호출과 관계되는 **`지역변수`** 와 **`매개변수`** 가 저장된다.

+ 이렇게 _Stack 영역에 저장되는 함수의 호출 정보_ 를 **스택 프레임(stack frame)** 이라고 합니다.

+ 함수 호출 시 생성되며, 함수가 끝나면 반환된다.

+ Stack 사이즈는 각 process 마다 할당되지만 process 가 Memory 에 로드될 때 Stack 사이즈가 고정되어 있어 _Runtime 시 Stack 사이즈를 바꿀 수 없다._

+ _명령 실행 시 자동으로 증가 또는 감소_ 하기 때문에 보통 `메모리의 마지막 번지를 지정`한다.


<br>


### Data 영역

+ Memory 의 Data 영역은 Program 의 **`전역 변수`** 와 **`정적(static) 변수`** 가 저장되는 영역입니다.

+ Data 영역은 Program 의 시작과 함께 할당되며, Program 이 종료되면 소멸합니다.


<br>


### Heap 영역

+ Memory 의 Heap 영역은 **사용자가 직접 관리할 수 있는 `그리고 해야만 하는`** Memory 영역입니다.

+ Heap 영역은 사용자에 의해 Memory 공간이 동적으로 할당되고 해제됩니다.

+ Heap 영역은 Memory 의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.
  
![image](https://github.com/lielocks/WIL/assets/107406265/0f793f41-ced6-4957-91c2-3b67ee5130d4)


<br>


## 가시성, 원자성

+ **가시성** : Multi Thread 환경에서 **모두 같은 상태의 공유 자원을 바라보는 것** 을 가시성이라고 한다.

  Thread 에서 어떤 객체를 update 할때 다른 thread 는 _변경이 되기 이전의 값을 가져오는 것을 해결_ 한 것이다.

  (Java 의 volatile 키워드 : *CPU 의 cahce 를 사용하지 않고* **`Main Memory에서 바로 가져옴으로써 해결`** 을 하는 것이다.)


+ **원자성** : Thread 들의 `수정`이 **공유 자원에 모두 반영** 되는 상태

  여러개의 Thread 에서 동시에 update 를 할 경우 하나만 반영되는게 아니라 **모두 반영** 이 되어야 한다.

  이거는 동기화 **(synchronized 키워드)** 로 해결을 한다. 그래서 **한번에 하나의 thread 만 접근** 하게 해서 해결하게 한다.


<br>


# 명령어의 구조와 주소 지정 방식

![image](https://github.com/lielocks/WIL/assets/107406265/a5d13e6d-839d-41bb-824a-b27b6cc90b5c)

+ **연산 코드** : 색으로 칠해져 있는 필드 값. 즉 명령어가 수행할 **'연산'**

+ **오퍼랜드** : 흰색 배경 필드 값.  즉 '연산에 사용할 데이터' 또는 **연산에 사용할 데이터가 저장된 위치**

  + 후자가 훨씬 더 많이 사용하므로 이를 **`주소 필드`** 라고 부르기도 한다. 

![image](https://github.com/lielocks/WIL/assets/107406265/8ac93f21-fc93-4e2f-a95b-5876f7b75ec6)

+ 명령어는 **연산 코드와 오퍼랜드**로 구성되어 있다.

+ **연산 코드** 는 명령어가 수행할 연산이다.

+ **오퍼랜드** 는 '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치' 이다.

+ '연산에 사용할 데이터가 저장된 위치' 가 훨씬 많이 쓰이므로 **주소 필드** 라고 하기도 한다.


<br>


### 오퍼랜드

오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기 보다는,

많은 경우 _연산에 사용할 데이터가 저장된 위치,_ 즉 **Memory 주소나 Register 이름** 이 담긴다.

그래서 오퍼랜드 필드를 주소 필드라고 부르기도 한다.

> 오퍼랜드는 **명령어 안에 하나도 없을 수도 있고, 한개만 있을 수도, 한개 이상일 수도 있다.**

![image](https://github.com/lielocks/WIL/assets/107406265/9a2541c3-09b9-4e85-9f72-b7183df7316c)


<br>


오퍼랜드가 하나도 없는 명령어를 0-주소 명령어,  오퍼랜드가 하나인 명령어를 1-주소 명령어, 두 개인 명령어를 2-주소 명령어, 세 개인 명령어를 3-주소 명령어라고 부른다.

![image](https://github.com/lielocks/WIL/assets/107406265/0a5d5e25-46bd-4c0c-861d-bff24b18212c)


<br>


### 연산 코드

연산 코드 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 아래의 4가지로 나눌 수 있다.

**1. 데이터 전송**

+ MOVE : 데이터를 옮겨라

+ STORE : Memory 에 저장하라

+ LOAD(FETCH) : Memory 에서 CPU 로 데이터를 가져와라

+ PUSH : Stack 에 데이터를 저장하라

+ POP : Stack 의 최상단 데이터를 가져와라


<br>


**2. 산술 / 논리 연산**

+ ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라

+ INCREAMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라

+ AND / OR / NOT : AND / OR / NOT 연산을 수행하라

+ COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라


<br>


**3. 제어 흐름 변경**

+ JUMP : 특정 주소로 실행 순서를 옮겨라

+ CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라

+ HALT : 프로그램의 실행을 멈춰라

+ CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라

+ RETRUN : CALL을 호출할 때 저장했던 주소로 돌아가라

> CALL 과 RETURN 은 **함수** 를 호출하고 리턴하는 명령어이다.


<br>


**4. 입출력 제어**

+ READ (INPUT) : 특정 입출력 장치로부터 데이터를 읽어라

+ WRITE (OUTPUT) : 특정 입출력 장치로 데이터를 써라

+ START IO : 입출력 장치를 시작하라

+ TEST IO : 입출력 장치의 상태를 확인하라


<br>


## 주소 지정 방식

오퍼랜드 필드에 숫자나 문자와 같이 연산에 필요한 데이터보다는 Memory 나 Register 의 address 를 담는 경우가 많다고 위에서 언급했었다.

그 이유는 **가령 명령어의 크기가 16비트, 연산 코드 필드가 4비트 인 2-주소 명령어에서는 오퍼랜드 필드당 6비트 정도밖에 남지 않는다.**

> **즉, 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 `2⁶가지로 64개` 밖에 되지 않는다.**

![image](https://github.com/lielocks/WIL/assets/107406265/a034e7ec-aebc-44e1-8a8c-530a593f1e9b)

![image](https://github.com/lielocks/WIL/assets/107406265/4409230c-6079-4178-b25e-0dbe29736128)


<br>


하지만 여기서 _오퍼랜드 필드 안에 Memory address 가 담긴다면_ 표현할 수 있는 데이터의 크기는 **하나의 Memory address 에 저장할 수 있는 공간만큼 커진다.**

예를 들어 한 주소에 16비트 를 저장할 수 있는 Memory 가 있다고 가정하면,

이 Memory 안에 데이터를 저장하고, 

오퍼랜드 필드 안에 해당 Memory address 를 명시한다면 표현할 수 있는 정보의 가짓수가 2¹⁶가지 로 확 커진다.

![image](https://github.com/lielocks/WIL/assets/107406265/6fcfca58-23ff-42d4-b129-8f84e5b3b0f5)

<br>

오퍼랜드 필드에 Memory address 가 아닌 **Register 이름을 명시할 때** 도 마찬가지이다.

이 경우 표현할 수 있는 정보의 가짓수는 해당 Register 가 저장할 수 있는 만큼 커진다.


<br>


연산 코드에 사용할 데이터가 저장된 위치, 즉 **연산의 대상이 되는 데이터가 저장된 위치**를 **`유효 주소 (effective address)`** 라고 한다.

_오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때_ `연산에 사용할 데이터 위치를 찾는 방법`을 _주소 지정 방식_ 이라고 한다. 

주소 지정 방식은 **유효 주소를 찾는 방법** 이다.


<br>


주소 지정 방식은 아래와 같이 5가지가 있다.

+ 즉시 주소 지정 방식

+ 직접 주소 지정 방식

+ 간접 주소 지정 방식

+ 레지스터 주소 지정 방식

+ 레지스터 간접 주소 지정 방식


<br>


### 1. 즉시 주소 지정 방식

+ 연산에 사용할 데이터를 **오퍼랜드 필드에 직접 명시** 하는 방법

단점 : 데이터의 크기가 작아진다.

장점 : 데이터를 Memory 나 Register 로부터 찾는 과정이 없기에 빠름


<br>


### 2. 직접 주소 지정 방식

+ **`오퍼랜드 필드`** 에 **유효 주소를 직접적으로 명시** 하는 방식

+ 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만, 여전히 **`유효 주소를 표현할 수 있는 범위`** 가 **연산 코드의 비트 수만큼 줄어들음**


<br>


### 3. 간접 주소 지정 방식

+ 직접 주소 지정 방식의 단점을 보완하기 위함

+ **`유효 주소의 주소`** 를 오퍼랜드 필드에 명시한다.

+ 직접 주소 지정 방식보다 표현할 수 있는 **유효 주소의 범위가 넓다.**

+ **두번의 메모리 접근** 이 필요하기에 _느리다._

![image](https://github.com/lielocks/WIL/assets/107406265/c01e4538-4bbd-4d5d-8fe1-9ffe48f41981)

> 참고 : CPU 가 메모리에서 데이터를 찾는 속도는 매우 느리다


<br>


### 4. Register 주소 지정 방식

+ `직접 주소 지정 방식` 과 비슷하게 **연산에 사용할 데이터를 저장한 Register**를 **`오퍼랜드 필드에 직접 명시`** 하는 방법

+ 특징이 모두 `직접 주소 지정 방식` 과 비슷함

+ Memory 보다 **Register 에서 데이터를 찾는 것이 훨씬 빠르므로** 직접 주소 지정 방식보다 빠름

![image](https://github.com/lielocks/WIL/assets/107406265/a82dd396-5420-4361-b166-91e6555fa4f3)


> ***Memory 와 Register***
>
> Memory 는 **CPU 밖** 에 있고, Register 는 **CPU 내부** 에 있다.
>
> 따라서 **CPU** 는 **Register 에 접근하는 속도가 훨씬 빠르다.**


<br>


### 5. Register 간접 주소 지정 방식

+ **연산에 사용할 데이터를 Memory 에 저장** 하고, **`그 주소(유효 주소) 를 저장한 Register`** 를 오퍼랜드 필드에 명시하는 방법

+ 유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만, **Memory 에 접근하는 횟수가 한번으로 줄어든다** 는 차이가 있다.

+ _Register 간접 주소 지정 방식_ 은 간접 주소 지정 방식보다 **빠르다.**

![image](https://github.com/lielocks/WIL/assets/107406265/105fd93b-15e4-48ab-82e0-62b705ff0c20)


<br>


정리하자면

**유효 주소 : 연산에 사용할 데이터가 저장된 위치**

+ 즉시 주조 지정 방식 : 연산에 사용할 데이터

+ 직접 주소 지정 방식 : 유효 주소 (메모리 주소)

+ 간접 주소 지정 방식 : 유효 주소의 주소

+ Register 주소 지정 방식 : 유효 주소 (register 이름)

+ Register 간접 주소 지정 방식 : 유효 주소를 저장한 register


<br>


## Memory 할당 알고리즘 

Process 는 Memory 내의 빈 공간에 적재되어야 한다.

Memory 내에 빈 공간이 여러개 있다면 Process 를 어디에 배치해야 할까?

비어 있는 Memory 공간에 Process 를 연속적으로 할당하는 방식을 알아보자.

여기에는 대표적으로 최초 적합(First-fit), 최적 적합(Best-fit), 최악 적합(Worst-fit)의 세 가지 방식이 있다.

![image](https://github.com/lielocks/WIL/assets/107406265/1a3564c5-7149-45ca-a648-f6c2e2a414cd)

이 Memory 에다가 2칸의 공간을 차지하는 데이터를 저장하려고 한다고 가정하자.

이때 Memory 할당 알고리즘마다 어떻게 데이터를 저장하는지 알아보자.


<br>


### 최초 적합 (First-Fit)

![image](https://github.com/lielocks/WIL/assets/107406265/726097c2-23bf-47df-8ae8-e92e96607bb6)

최초 적합은 가장 최초로 발견되는 곳에 데이터를 저장한다. 

Memory 를 **순차적으로 탐색하다가 가장 먼저 발견한 곳에 데이터를 저장** 하는 방법이다.


<br>


### 최적 적합 (Best-Fit)

최적 적합은 데이터가 저장되기에 가장 적절한 곳에 데이터를 저장한다.

Memory 를 탐색해서 **가장 먼저 발견한 가장 적절한 곳** 을 찾아 데이터를 저장하는 방법이다.

즉, 가장 딱 맞는 곳에 데이터를 저장하기 대문에 **`Memory 의 낭비가 가장 적다.`**

![image](https://github.com/lielocks/WIL/assets/107406265/8b219682-0ad7-4307-96f7-a1619d58ce97)

이렇게만 보면 최적 적합이 가장 좋아보이지만 _처음부터 끝까지 모두 탐색_ 을 해야한다는 단점이 있다.

그만큼 비교를 많이 해야하고 그렇기 때문에 시간이 오래걸린다.


<br>


### 최악 적합 (Worst-Fit)

최악 적합은 Process 를 적재하는데 가장 크기가 안 맞는 곳에 Process 를 적재하는 방법이다.

딱 맞는 공간이 있는데도 데이터의 크기와 가장 안맞는 Memory 에 저장하기 때문에 Worst이다.

![image](https://github.com/lielocks/WIL/assets/107406265/9b4c69c2-3a19-40ec-aba9-b527f8144c8c)

최악 적합도 최적 적합처럼 _하나하나 탐색_ 을 해야한다.

Memory 낭비까지 발생하기 때문에 가장 선호도가 낮다.


<br>


### 외부 단편화 (external fragmentation)

Process 를 Memory 에 연속적으로 배치하는 연속 Memory 할당은 당연하게 느껴질 수 있지만, 
사실 이는 **Memory 를 효율적으로 사용하는 방법이 아니다.** 

왜냐하면 **`연속 메모리`는 외부 단편화** 라는 문제를 내포하고 있기 때문이다.

아무런 Process 도 적재되지 않은 상태의 Memory 전체를 생각해봅시다.


<br>


운영체제 영역에는 운영체제가 적재되어 있고, 사용자 영역에는 어떠한 Process 도 적재되어 있지 않다.

이제 사용자 영역에 하나둘씩 Process 들이 적재되는 상황을 가정해보자. 

이때 사용자 영역의 크기는 200MB라고 하자. 

사용자 영역에 크기가 `50MB인 Process A` `30MB인 Process B` `100MB인 Process C` `20MB인 Process D` 를 차례대로 적재해야 한다면 이 Process 들을 Memory 에 어떻게 배치하는 것이 좋을까?

차례대로 적재하면 모두 200MB 이기 때문에 저장 공간에 딱 맞게 적재된다.


<br>


이제 Process B, D 의 실행이 끝났다고 해보자. 

이 Process 들은 실행이 끝났기 때문에 더 이상 Memory 에 남아 있는 필요가 없다.

Process B, D가 Memory 를 떠나면 Memory 에 A,B,C,D 순으로 적재되어 있던 Process 들이 `A(50MB), X(30MB), C(100MB), X(20MB)` 와 같은 상태가 되고 'X' 와 같은 총 30MB, 20MB의 **빈 공간** 이 생긴다.


<br>


한 가지 질문이 있다. **현재 메모리에 남아 있는 빈 공간의 총합은 몇 MB일까?**

당연히 50MB 이다.


<br>


그렇다면 두번째 질문이 있다. _현재 상황에서 50MB 크기의 Process 를 적재할 수 있을까?_

불가능하다.

빈 공간의 총합은 50MB 이지만 **빈 공간이 따로 떨어져 있기 때문에** 50MB 크기의 Process 가 적재될 수 없기 때문이다.

Process 들이 Memory 에 연속적으로 할당되는 환경에서는 위와 같이 Process 들이 실행되고 종료되기를 반복하며 Memory 사이 사이에 빈 공간들이 생긴다. 

**Process 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 Process 를 적재하기 어려운 상황을 초래하고, 결국 Memory 낭비로 이어진다.** 

이러한 현상이 **`외부 단편화`** 이다.


<br>


## 변수

### 지역변수 (Stack 영역)

- 지역안에서 선언된 변수

- 그 영역의 닫는 중괄호 `(})` 를 만났을 때, Memory 에서 해제된다.

- 사용자가 _직접 초기화_ 해야 한다.

- **다른 영역에서 접근할 수 없기 때문에** 보안성이 뛰어나다.

```java
package
 
public class Main {
 
 
    public static void main(String[] args) {
        int a = 0; //지역변수.
    }
}
```

<br>


### 전역변수 (Data 영역)

- Class 영역 안에 있고, 전체 영역에서 사용 가능한 변수

- Class 영역 외의 어떠한 영역에도 포함되어 있지 않다.

- **new** 를 만났을 때 `초기화` 된다.

- _Program 종료시_ Memory 에서 해제된다.

- 다른 영역에서도 **접근 할 수 있기 때문에** 보안성이 상대적으로 낮다.

```java
package 함수2.형성평가02;
 
public class Main {
 
    int a = 0; //전역변수.
    
    public static void main(String[] args) {
    
    }
}
```


<br>


### static 변수 (Data 영역)

- Compile 을 하게 되면 **가장 먼저 Memory 에 올라가고,** 어떠한 경우에도 **초기화가 되지 않는다.**

- 단, **Program 종료시 Memory 에서 해제된다.**

- Memory 에 고정되기 때문에 남용시 Memory 혹은 Program 실행 속도에 악영향을 준다.

