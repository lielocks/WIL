# Program 과 Process 의 차이
![image](https://github.com/lielocks/WIL/assets/107406265/d72e478a-cd99-4d6e-b915-ac521669b8bc)

+ Program : 어떤 작업을 위해 실행할 수 있는 명령어 리스트를 포함하는 파일을 뜻한다.

+ Process : 운영체제 입장에서 하나의 작업 단위이며, 컴퓨터에서 연속적으로 **실행되고 있는 컴퓨터 프로그램** 을 말한다.
  + **실행파일(program)** 이 **memory** 에 적재되어 **CPU**를 할당 받아 실행(연산)되는 것을 **Process** 라고 한다.


Program 은 일반적으로 하드 디스크 등의 보조기억장치에 저장된 실행 코드를 뜻하고, 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 칭한다.

즉, 실행 중인 프로그램을 뜻한다.
하나의 프로그램을 여러번 구동하면 여러개의 프로세스가 메모리상에서 실행되는 것이다.

<br>

### Process 의 일반적인 구조

+ 프로세스는 다음과 같이 4가지 영역으로 나눌 수 있다.
  1. Stack : 임시 데이터 (함수 호출, 로컬 변수 등) 이 저장되는 영역
  2. Heap : 코드에서 동적으로 생성되는 데이터가 저장되는 영역
  3. Data : 전역 변수 / 초기화된 데이터가 저장되는 영역
  4. Text (Code) : 컴파일된 소스 코드가 저장되는 영역

![image](https://github.com/lielocks/WIL/assets/107406265/605b7714-d004-4980-9c77-355eb9c1a65d)

<br>

### Code 영역

+ 메모리의 코드 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(text) 영역이라고도 부릅니다.

+ CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 됩니다.
  
<br>

### Stack 영역

+ 프로그램이 자동으로 사용하는 메모리 영역으로 함수 호출과 관계되는 지역변수와 매개변수가 저장된다.

+ 이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 합니다.

+ 함수 호출 시 생성되며, 함수가 끝나면 반환된다.

+ stack 사이즈는 각 프로세스마다 할당되지만 프로세스가 메모리에 로드될 때 stack 사이즈가 고정되어 있어 런타임 시 stack 사이즈를 바꿀 수 없다.

+ 명령 실행 시 자동으로 증가 또는 감소하기 때문에 보통 메모리의 마지막 번지를 지정한다.

<br>

### Data 영역

+ 메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역입니다.

+ 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸합니다.

<br>

### Heap 영역

+ 메모리의 Heap 영역은 사용자가 직접 관리할 수 있는 `그리고 해야만 하는` 메모리 영역입니다.

+ Heap 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다.

+ Heap 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당됩니다.
![image](https://github.com/lielocks/WIL/assets/107406265/0f793f41-ced6-4957-91c2-3b67ee5130d4)

<br>

## 가시성, 원자성
+ **가시성** : 멀티 스레드 환경에서 ***모두 같은 상태의 공유자원을 바라보는 것*** 을 가시성이라고 한다.

  스레드에서 어떤 객체를 업데이트 할때 다른 스레드는 변경이 되기 이전의 값을 가져오는 것을 해결한 것이다.

  (자바의 volatile 키워드 : *CPU 의 캐시를 사용하지 않고* **`Main Memory에서 바로 가져옴으로써 해결`** 을 하는 것이다.)

+ **원자성** : 스레드들의 `수정`이 **공유 자원에 모두 반영** 되는 상태

  여러개의 스레드에서 동시에 업데이트를 할 경우 하나만 반영되는게 아니라 `모두 반영` 이 되어야 한다.

  이거는 동기화 (synchronized 키워드) 로 해결을 한다. 그래서 **한번에 하나의 스레드만 접근하게 해서 해결** 하게 한다.

<br>

# 명령어의 구조와 주소 지정 방식

![image](https://github.com/lielocks/WIL/assets/107406265/a5d13e6d-839d-41bb-824a-b27b6cc90b5c)

+ **연산 코드** : 색으로 칠해져 있는 필드 값. 즉 **'명령어가 수행할 연산'**

+ **오퍼랜드** : 흰색 배경 필드 값.  즉 '연산에 사용할 데이터' 또는 **'연산에 사용할 데이터가 저장된 위치'**

  + 후자가 훨씬 더 많이 사용하므로 이를 **`주소 필드`** 라고 부르기도 한다. 

![image](https://github.com/lielocks/WIL/assets/107406265/8ac93f21-fc93-4e2f-a95b-5876f7b75ec6)

+ 명령어는 **연산 코드와 오퍼랜드**로 구성되어 있다.

+ **연산 코드** 는 명령어가 수행할 연산이다.

+ **오퍼랜드** 는 '연산에 사용할 데이터' 또는 '연산에 사용할 데이터가 저장된 위치' 이다.

+ '연산에 사용할 데이터가 저장된 위치' 가 훨씬 많이 쓰이므로 **주소 필드** 라고 하기도 한다.

<br>

### 오퍼랜드

오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기 보다는,

많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다.

그래서 오퍼랜드 필드를 주소 필드라고 부르기도 한다.

**오퍼랜드는 명령어 안에 하나도 없을 수도 있고, 한개만 있을 수도, 한개 이상일 수도 있다.**

![image](https://github.com/lielocks/WIL/assets/107406265/9a2541c3-09b9-4e85-9f72-b7183df7316c)

<br>

오퍼랜드가 하나도 없는 명령어를 0-주소 명령어,  오퍼랜드가 하나인 명령어를 1-주소 명령어, 두 개인 명령어를 2-주소 명령어, 세 개인 명령어를 3-주소 명령어라고 부른다.

![image](https://github.com/lielocks/WIL/assets/107406265/0a5d5e25-46bd-4c0c-861d-bff24b18212c)

<br>

### 연산 코드
연산 코드 종류는 매우 많지만, 가장 기본적인 연산 코드 유형은 아래의 4가지로 나눌 수 있다.

**1. 데이터 전송**
+ MOVE : 데이터를 옮겨라

+ STORE : 메모리에 저장하라

+ LOAD(FETCH) 메모리에서 CPU로 데이터를 가져와라

+ PUSH : 스택에 데이터를 저장하라

+ POP : 스택의 최상단 데이터를 가져와라

<br>

**2. 산술 / 논리 연산**
+ ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라

+ INCREAMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라

+ AND / OR / NOT : AND / OR / NOT 연산을 수행하라

+ COMPARE : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라

<br>

**3. 제어 흐름 변경**
+ JUMP : 특정 주소로 실행 순서를 옮겨라

+ CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라

+ HALT : 프로그램의 실행을 멈춰라

+ CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라

+ RETRUN : CALL을 호출할 때 저장했던 주소로 돌아가라

> CALL 과 RETURN은 **함수** 를 호출하고 리턴하는 명령어이다.

<br>

**4. 입출력 제어**
+ READ (INPUT) : 특정 입출력 장치로부터 데이터를 읽어라

+ WRITE (OUTPUT) : 특정 입출력 장치로 데이터를 써라

+ START IO : 입출력 장치를 시작하라

+ TEST IO : 입출력 장치의 상태를 확인하라

<br>

## 주소 지정 방식
오퍼랜드 필드에 숫자나 문자와 같이 연산에 필요한 데이터보다는 메모리나 레지스터의 주소를 담는 경우가 많다고 위에서 언급했었다.

그 이유는 **가령 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령어에서는 오퍼랜드 필드당 6비트 정도밖에 남지 않는다.**

**즉, 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2⁶가지로 64개 밖에 되지 않는다.**
![image](https://github.com/lielocks/WIL/assets/107406265/a034e7ec-aebc-44e1-8a8c-530a593f1e9b)
![image](https://github.com/lielocks/WIL/assets/107406265/4409230c-6079-4178-b25e-0dbe29736128)

<br>

하지만 여기서 `오퍼랜드 필드 안에 메모리 주소`가 담긴다면 표현할 수 있는 데이터의 크기는 ***하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.***

예를 들어 한 주소에 16비트를 저장할 수 있는 메모리가 있다고 가정하면, 이 메모리 안에 데이터를 저장하고, 오퍼랜드 필드 안에 해당 메모리 주소를 명시한다면 표현할 수 있는 정보의 가짓수가 2¹⁶가지로 확 커진다.

![image](https://github.com/lielocks/WIL/assets/107406265/6fcfca58-23ff-42d4-b129-8f84e5b3b0f5)

<br>

오퍼랜드 필드에 메모리 주소가 아닌 **레지스터 이름을 명시할 때** 도 마찬가지이다.
이 경우 표현할 수 있는 정보의 가짓수는 해당 레지스터가 저장할 수 있는 만큼 커진다.

연산 코드에 사용할 데이터가 저장된 위치, 즉 **연산의 대상이 되는 데이터가 저장된 위치**를 **`유효 주소 (effective address)`** 라고 한다.

오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식이라고 한다. 

주소 지정 방식은 ***유효 주소를 찾는 방법*** 이다.

주소 지정 방식은 아래와 같이 5가지가 있다.

+ 즉시 주소 지정 방식

+ 직접 주소 지정 방식

+ 간접 주소 지정 방식

+ 레지스터 주소 지정 방식

+ 레지스터 간접 주소 지정 방식

<br>

**1. 즉시 주소 지정 방식**
+ 연산에 사용할 데이터를 **오퍼랜드 필드에 직접 명시** 하는 방법

단점 : 데이터의 크기가 작아진다.
장점 : 데이터를 메모리나 레지스터로부터 찾는 과정이 없기에 빠름

<br>

**2. 직접 주소 지정 방식**
+ **`오퍼랜드 필드`** 에 **유효 주소를 직접적으로 명시** 하는 방식

+ 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만, 여전히 **`유효 주소를 표현할 수 있는 범위`** 가 **연산 코드의 비트 수만큼 줄어들음**

<br>

**3. 간접 주소 지정 방식**
+ 직접 주소 지정 방식의 단점을 보완하기 위함

+ **`유효 주소의 주소`** 를 오퍼랜드 필드에 명시한다.

+ 직접 주소 지정 방식보다 표현할 수 있는 **유효 주소의 범위가 넓다.**

+ ***두번의 메모리 접근이 필요*** 하기에 `느리다.`

![image](https://github.com/lielocks/WIL/assets/107406265/c01e4538-4bbd-4d5d-8fe1-9ffe48f41981)

> 참고 : CPU 가 메모리에서 데이터를 찾는 속도는 매우 느리다

<br>

**4. 레지스터 주소 지정 방식**
+ `직접 주소 지정 방식` 과 비슷하게 **연산에 사용할 데이터를 저장한 레지스터**를 **`오퍼랜드 필드에 직접 명시`** 하는 방법

+ 특징이 모두 `직접 주소 지정 방식` 과 비슷함

+ 메모리보다 **레지스터에서 데이터를 찾는 것이 훨씬 빠르므로** 직접 주소 지정 방식보다 빠름

![image](https://github.com/lielocks/WIL/assets/107406265/a82dd396-5420-4361-b166-91e6555fa4f3)

>
> **메모리와 레지스터**
>
> 메모리는 CPU 밖에 있고, 레지스터는 CPU 내부에 있다.
>
> 따라서 CPU는 **레지스터에 접근하는 속도가 훨씬 빠르다.**

<br>

**5. 레지스토 간접 주소 지정 방식**
+ **연산에 사용할 데이터를 메모리에 저장**하고, **`그 주소(유효 주소) 를 저장한 레지스터`** 를 오퍼랜드 필드에 명시하는 방법

+ 유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만, **메모리에 접근하는 횟수가 한번으로 줄어든다** 는 차이가 있다.

+ 레지스터 간접 주소 지정 방식은 간접 주소 지정 방식보다 **빠르다.**

![image](https://github.com/lielocks/WIL/assets/107406265/105fd93b-15e4-48ab-82e0-62b705ff0c20)

<br>

정리하자면

**유효 주소 : 연산에 사용할 데이터가 저장된 위치**
+ 즉시 주조 지정 방식 : 연산에 사용할 데이터

+ 직접 주소 지정 방식 : 유효 주소 (메모리 주소)

+ 간접 주소 지정 방식 : 유효 주소의 주소

+ 레지스터 주소 지정 방식 : 유효 주소 (레지스터 이름)

+ 레지스터 간접 주소 지정 방식 : 유효 주소를 저장한 레지스터

<br>

## 변수

### 지역변수 (Stack 영역)

- 지역안에서 선언된 변수

- 그 영역의 닫는 중괄호 (}) 를 만났을 때, 메모리에서 해제된다.

- 사용자가 직접 초기화해야 한다.

- 다른 영역에서 접근할 수 없기 때문에 보안성이 뛰어나다.

```java
package
 
public class Main {
 
 
    public static void main(String[] args) {
        int a = 0; //지역변수.
    }
}
```

<br>

### 전역변수 (Data 영역)

- 클래스 영역 안에 있고, 전체 영역에서 사용 가능한 변수

- 클래스 영역 외의 어떠한 영역에도 포함되어 있지 않다.

- new 를 만났을 때 초기화 된다.

- 프로그램 종료시 메모리에서 해제된다.

- 다른 영역에서도 접근 할 수 있기 때문에, 보안성이 상대적으로 낮다.

```java
package 함수2.형성평가02;
 
public class Main {
 
    int a = 0; //전역변수.
    
    public static void main(String[] args) {
    
    }
}
```

<br>

### static 변수 (Data 영역)

- 컴파일을 하게 되면 가장 먼저 메모리에 올라가고, 어떠한 경우에도 초기화가 되지 않는다.

- 단, 프로그램 종류 시 메모리에서 해제된다.

- 메모리에 고정되기 때문에 남용시 메모리 혹은 프로그램 실행 속도에 악영향을 준다.

<br>

