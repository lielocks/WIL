# 캐시 메모리와 지역성 그리고 캐시 라인


### 캐시

**캐시 메모리란 (Cache Memory)?**

+ 사용 목적 : CPU 와 주기억장치의 속도 차이로 인한 CPU 대기 시간을 최소하 시키기 위해 CPU 와 주기억장치 사이에 설치하는 고속 반도체 기억장치


![image](https://github.com/lielocks/WIL/assets/107406265/74640f3b-14ae-4579-8d3c-59289a6ef8ff)



+ 속도가 빠른 장치와 느린 장치간의 병목 현상 줄여주고 main memory 의 CPU 사이에 위치한다.

+ cache가 효율적으로 동작하기 위해서는 CPU가 참조할 정보에 대한 예측이 잘 되어 있어야 한다.

  + 즉, cache 의 적중률 (Hit-rate)를 극대화 시키는게 포인트 !
  + 이떄 나오는 개념이 cache의 지역성 (Locality)



![image](https://github.com/lielocks/WIL/assets/107406265/82d4fe22-724e-40a8-aeed-bdce378553bb)


</br>


### 캐시의 지역성 ? 

1. 데이터에 대한 접근이 시간적 - 공간적으로 가깝게 발생하는 것을 뜻한다

2. 이때 프로그램은 정보를 균일하게 참조하는게 아니라, 어느 한 순간에 특정 부분을 집중 참조 할 것이라는 전제 조건이 존재한다.
   + **시간지역성 temporal locality** : 최근에 참조된 데이터가 곧 다시 참조되는 특성 // 최근에 엑세스된 프로그램이나 데이터가 가까운 미래에 다시 액세스 될 가능성이 높다.
  
     
   + **공간지역성 spatial locality** : 최근에 참조된 데이터와 인접한 데이터가 참조될 가능성이 높은 특성 // 기억 장치 내에 인접하여 저장되어 있는 데이터들이 연속적으로 액세스 될 가능성이 높다.
  

   + **순차적 지역성 sequential locality** : 분기 (branch) 가 발생하지 않는 한, 명령어들은 기억 장치에 저장된 순서대로 인출되어 실행된다.


</br>



#### 캐시 설계 목표

+ 캐시 적중률의 극대화

+ 캐시 엑세스 시간의 최소화

+ 캐시 미스에 따른 지연 시간의 최소화

+ 주기억장치와 캐시간의 데이터 일관성 유지 및 그에 따른 overhead 최소화


</br>


### 캐시 라인 ?

**캐시 라인이 존재하는 이유**



캐시 메모리는 메인 메모리에 비해 크기가 매우 작기 때문에, 메인 메모리와 1:1 매칭이 불가능하다. 


캐시가 아무리 CPU에 가깝게 위치하더라도, 데이터가 캐시 내의 어느곳에 저장되어 있는지 찾기 어렵다면 비효율적인 시스템이 된다.

그래서 캐시에 데이터를 저장할 때는 캐싱 라인이라는 단위의 묶음으로 저장하는데, 이때 빈번하게 사용되는 데이터의 주소들이 `일정한 태그들로 묶여있으면` 아무래도 찾기가 쉬워질 것이다.



캐시는 프로세서 가깝게 위치하며 자주 사용되는 데이터들은 저장하는 것


</br>



**목적 데이터를 바로 접근하여 출력**할 수 있어야 캐시가 의미가 있기 때문에, 특정 자료구조를 사용하여 묶음으로 저장해놓는데 이를 `캐싱라인`이라 칭함


즉 캐시 메모리의 매핑 프로세스 라고 말할 수 있다.


</br>


#### 캐시의 라인 종류


**1. 직접 매핑 Direct Mapping**

+ 메모리 주소와 캐시의 순서를 일치시켜 지정된 캐시 라인으로만 사상하는 방식

+ 즉, 캐시 1에는 메모리를 110번을  캐시 2에는 메모리 1120번을 위치시키는 것

+ 하지만 특정 메모리 위치의 값을 자주 불러다 사용한다면 저장할 캐시 공간은 1개이므로 매번 캐시  교체 일어남

+ 즉 적중률 성능이 낮지만 구현이 간단하고 쉬움


![image](https://github.com/lielocks/WIL/assets/107406265/ea10fae0-9c1f-4e95-84eb-eecdb2b15c49)


![image](https://github.com/lielocks/WIL/assets/107406265/0dca0980-6b02-4169-abe0-a0150b77d19c)


![image](https://github.com/lielocks/WIL/assets/107406265/1f969a88-a41f-455b-ba31-177c29a1804a)


![image](https://github.com/lielocks/WIL/assets/107406265/8c33eee7-5e95-4643-a781-8b5fa14623bd)


![image](https://github.com/lielocks/WIL/assets/107406265/924bd5db-81ff-4a32-8c31-fa372e0937c4)


![image](https://github.com/lielocks/WIL/assets/107406265/d12022af-be07-4710-864f-7d099871f0cc)


</br>



**2. 연관 매핑 Associative Mapping**

+ 순서를 일치시키지 않고 필요한 메모리 값을 캐시의 어디든 편하게 저장

+ 찾는 과정은 복잡하고 느리지만 필요한 캐시 위주로 저장하기에 적중률 높음
  + 캐시는 일반 메모리보다 속도가 빠르므로 캐시의 검색량 보다 적중률을 신경쓰는게 바림직



 ![image](https://github.com/lielocks/WIL/assets/107406265/46bda58e-c4a2-4d5c-a9f7-e74b9efacef1)


</br>



**3. 세트 연관 매핑 Set Associative Mapping**

+ 연관 매핑과 직접 매핑을 합쳐놓은 방식

+ 순서를 일치시키면서 일정 그룹을 두지만, 그 그룹내에서는 편하게 저장하는 방식.

+ 블록화가 되어 있어 검색에 조금 더 효율적이며 적중률이 많이 떨어지지도 않는다.


![image](https://github.com/lielocks/WIL/assets/107406265/ec78e6d5-61ae-428f-af07-f98965670057)



![image](https://github.com/lielocks/WIL/assets/107406265/27e206e2-0cd6-4873-88b7-e42cf63d528b)



![image](https://github.com/lielocks/WIL/assets/107406265/cc74195b-d38a-4e93-b92c-b878348c3a6c)
