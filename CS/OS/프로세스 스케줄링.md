# 개요 

+ **프로세스**란, 실행 중인 프로그램을 말한다.

+ 우리가 사용한느 컴퓨터에서는 정말 많은 **프로세스**들이 실행되고 있다.

![image](https://github.com/lielocks/WIL/assets/107406265/5e26059b-d83d-443a-98c9-fa80dfc6427f)

+ 프로세스들은 실행을 위해 **CPU, Memory 등의 자원** 들을 **OS**로부터 할당받아 사용한다.

+ 운영체제가 프로세스들에게 효율적으로 자원을 할당하는 것을 **프로세스 스케줄링**이라고 한다.

<br>

## 프로그램

+ 프로그램이란, **`명령어들의 집합`**이다.

+ 여기서 말하는 명령어는 CPU가 실행하는데 필요한 명령어이다.

+ 즉, 프로그래밍 언어로 작성된 소스 코드를 컴파일하여 만들어진 **명령어들의 집합** 이다.
  + Ex) UNIX 계열 운영체제의 `.out 파일`, Windows 운영체제의 `.exe 파일`

+ 프로그램은 **보조기억장치** 에 저장되어 있다.

![image](https://github.com/lielocks/WIL/assets/107406265/20730fab-f244-44d9-9676-53acd8339273)

<br>

## 프로세스 Process
+ **프로그램이 실행되어 메모리에 적재된 상태**를 말한다.

+ **실행 중인 프로그램** 이라고 볼 수 있다.
  + Ex) 게임 프로그램(실행파일) 실행 → 게임 프로세스 생성.

+ 프로세스 생성 시, **OS**가 프로세스에 필요한 **자원을 할당**한다.

+ 이때, 프로세스들은 각각의 **독립된 메모리 영역** 을 할당 받는다.
  + 각 프로세스들은 자신만의 독립된 메모리 영역을 가지고 있으므로, ***프로세스 간 통신은 불가능하다.***
 
  + **`프로세스 간 통신`** 을 위해서는 **`파이프, 시그널, 공유메모리, 파일`** 등을 사용해야 한다.
    ![image](https://github.com/lielocks/WIL/assets/107406265/b5074035-3933-48a2-b459-a0198de09dd9)

<br>

## 프로세스 제어 블록 (Process Control Block)
+ **프로세스와 관련된 정보**를 저장하는 곳이다.

+ 각 프로세스마다 자신만의 PCB를 가지고 있다.

+ 프로세스 ID(PID), 프로세스 상태 등의 정보들을 저장하고 있다.

+ 운영체제는 **PCB를 통해 각 프로세스를 식별** 한다.

+ PCB는 중요한 정보들을 저장하고 있기 때문에, **커널 메모리 영역에 저장**된다.
  + **`커널 메모리 영역 (OS 영역)`** : **시스템에서 사용해야 하는 필수적인 데이터** 나 중요한 정보들을 저장하기 위해 사용하는 메모리 영역
  + **`사용자 메모리 영역`** : **각 프로세스가 할당 받는** 메모리 영역 (Code Data Heap Stack)

![image](https://github.com/lielocks/WIL/assets/107406265/3dfbf854-2eff-4c5a-9c20-2ce2da3b429d)

+ **PCB에 저장되는 정보들**은 아래와 같다.
  + **프로세스 ID (PID)** : 프로세스 식별 번호
 
  + **레지스터 값** : 프로세스가 사용하던 레지스터 값 (프로그램 카운터 등)
 
  + **프로세스 상태** : CPU를 사용 중인 상태인지, CPU 사용을 위해 기다리는 상태인지 등

  + **CPU 스케줄링 정보** : 언제, 어떤 순서로 CPU를 할당 받을지
 
  + **메모리 관리 정보** : 프로세스가 적재된 메모리 위치
 
  + **사용한 파일 및 입출력 장치 정보** : 프로세스가 어떤 입출력 장치나 파일을 사용했는지

<br>

## 문맥 교환 Context Switching
+ 모든 프로세스들은 실행을 위해 CPU 자원이 필요하지만, **CPU 자원은 한정**되어 있다.

+ 따라서 **모든 프로세스는 동시에 CPU 사용이 불가능**하며, 프로세스들은 **차례대로 돌아가면서** 특정 시간 동안 PCU를 사용한다.

+ 즉 프로세스들은 **운영체제가 할당해준 특정 시간만큼 번갈아가면서** CPU를 사용한다.

+ 이때 실행 중이던 프로세스에서 다른 프로세스로 실행 순서가 넘어갈 때, 운영체제는 **현재까지 실행 중이던 프로세스의 정보를 PCB에 저장하고**,
  **다음에 실행할 프로세스의 정보를 해당 프로세스의 PCB로부터 불러온다.***

+ 이 과정을 **문맥 교환**이라고 한다.

![image](https://github.com/lielocks/WIL/assets/107406265/74122b47-4234-4e2a-99bc-3b95de2d6b97)

+ 문맥 교환은 **아주 빠르게 수행**되기 때문에 (현대 시스템에서는 수십 usec 정도), 사용자 입장에서는 여러개의 프로세스가 **동시에 실행되고 있는 것처럼 보인다.**

+ 문맥 교환이 자주 일어나게 된다면, 그만큼 **오버헤드**가 발생할 수 있다.
  + 오버헤드 : 특정 기능을 수행하는데 추가적으로 시간, 자원이 소모되는 것

<br>

## 프로세스 상태 Process Status

+ 프로세스가 실행될 때, 각 프로세스는 **여러 가지의 상태를 거치며 실행**된다.
![image](https://github.com/lielocks/WIL/assets/107406265/8680f95f-e617-43b7-a0b6-476dd41b60e8)
  1. 생성 상태 (NEW) : 프로세스가 이제 막 **메모리에 적재되어 PCB를 할당 받은 상태**
 
  2. 준비 상태 (READY) : CPU를 할당 받으면 실행이 가능하지만, 자신의 **차례를 기다리는 상태**
 
  3. 실행 상태 (RUNNING) : CPU를 할당 받아 **실행 중인 상태**
     + **일정 시간 동안**만 CPU 사용이 가능하다.
    
     + 할당된 시간을 모두 사용하면 **타이머 인터럽트**가 발생하며 다시 준비 상태로 변경된다.

  4. 대기 상태 (WAITING) : 입출력 요청을 받게 되어 입출력 작업을 완료할 때까지 **대기하는 상태**
     + 입출력 작업이 끝나고 **입출력 완료 인터럽트**를 받을 때까지 대기하는 상태이다.
    
     + 정확히는 **특정 이벤트가 일어나기까지 기다리는 것**이며, 대부분의 이벤트가 입출력 작업이다.
    
  5. 종료 상태 (END) : 프로세스가 종료된 상태

<br>

## 프로세스 스케줄링 Process Scheduling
+ 운영체제가 **프로세스들에게 공정하고 합리적으로 자원을 배분하는 것**을 말한다.

+ 특정 자원의 할당을 원하는 프로세스들은 해당 자원의 **스케줄링 큐**에서 대기한다.
  + 대표적인 스케줄링 큐에는 **준비큐**와 **대기큐**가 있다.
    + **`준비 큐`** : **CPU 사용**을 위해 기다리는 큐
    + **`대기 큐`** : **입출력 장치 사용**을 위해 기다리는 큐
![image](https://github.com/lielocks/WIL/assets/107406265/9d125542-cffd-4efd-8e5d-ef23e200fc34)
  + 스케줄링 큐는 반드시 선입선출(FIFO) 방식은 아니며, **프로세스들이 대기하는 공간**일 뿐이다.

+ 운영체제는 스케줄링 큐에서 대기하는 각 프로세스들의 **우선순위**를 고려하여 자원을 배분한다.
![image](https://github.com/lielocks/WIL/assets/107406265/4ad092a6-9381-426f-9e4d-37b2898a759b)
![image](https://github.com/lielocks/WIL/assets/107406265/73c23f91-4d90-4f6b-9e6e-5a4224cccfb0)
![image](https://github.com/lielocks/WIL/assets/107406265/5c8520c3-ccb5-45cf-ae4a-4820006045ae)

<br>

## 프로세스 스케줄링 알고리즘 Process Scheduling Algorithm

+ 운영체제가 **프로세스 스케줄링을 위해 사용하는 실질적인 방법**이다.

+ 대표적인 CPU 할당을 위한 프로세스 스케줄링 알고리즘의 종류는 아래와 같다.

  1. **선입 선처리 스케줄링**
     + 준비 큐에 삽입된 순서대로 CPU를 할당해주는 방식이다.
    
     + 먼저 실행되는 프로세스들의 실행 시간이 길다면, 대기 중인 프로세스들이 기다리는 시간이 매우 길어질 수 있다.

<br>

  2. **최단 작업 우선 스케줄링**
     + 실행 시간이 가장 짧은 프로세스부터 CPU를 할당해주는 방식이다.

<br>

  3. **라운드 로빈 스케줄링**
     + **준비 큐에 삽입된 순서대로 PCU를 할당**하지만, **정해진 시간 (타임 슬라이스) 만큼만 할당**해주는 방식이다.
    
     + 정해진 시간동안 전부 실행되지 못했다면, 맨 마지막 순서로 돌아가서 다시 기다린다.
     ![image](https://github.com/lielocks/WIL/assets/107406265/1320eafb-d99e-40ae-8d0c-b161e323c0a0)

<br>

  4. **최소 잔여 시간 우선 스케줄링**
    + 정해진 시간만큼 CPU를 할당하되, 다음 프로세스는 남은 작업 시간이 가장 적은 프로세스를 선택하는 방식이다.

<br>

  5. **우선순위 스케줄링**
     + 프로세스들에 우선순위를 부여하고, 우선순위가 높은 프로세스부터 실행시키는 방식이다.
    
     + 우선순위가 같다면, `선입 선처리`로 처리한다.
    
     + 우선순위가 낮은 프로세스는 무한정 실행되지 못하는 `기안(Starvation) 현상`이 발생한다.
    
     + 기아 현상 방지를 위해 오래 기다린 프로세스의 우선순위를 점차 높이는 에이징 (Aging) 기법을 사용한다.

<br>

  6. **다단계 큐 스케줄링 Multilevel Queue Scheduling**
     + 우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식이다.
    
     + 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리한다.
    
     + 우선순위가 가장 높은 큐가 비어 있으면, 그 다음 우선순위 큐를 처리한다.
    
     + 우선 순위가 낮은 프로세스는 기아 현상이 발생할 수 있다.

     ![image](https://github.com/lielocks/WIL/assets/107406265/1dfd987d-875e-431b-9a10-b657320030f2)

<br>

  7. **다단계 피드백 큐 스케줄링**
     + **큐 간의 이동**이 가능한 다단계 큐 스케줄링이다.
    
     + **우선순위**가 가장 높은 큐부터 처리를 하되, 일정 시간(타임 슬라이스)동안 못 끝낸 경우 **그 다음 우선 순위 큐**로 다시 이동하여 대기한다.
    
     + CPU 사용 시간이 길수록 우선 순위가 내려가게 된다.
    
     + 즉, **`CPU 사용 시간이 긴 CPU 집중(CPU Bound) 프로세스는 우선 순위가 상대적으로 낮아지고,`**
       **`CPU 사용 시간이 짧고 입출력 작업이 많은 입출력 집중(I/O Bound) 프로세스는 우선 순위가 상대적으로 높아진다.`**
       ![image](https://github.com/lielocks/WIL/assets/107406265/f30e7a9a-a9b1-49d1-88c9-22243da2b522)

     + 또한, 에이징 기법을 통해 기아 현상을 방지한다.
       ![image](https://github.com/lielocks/WIL/assets/107406265/d49893bf-581e-4d89-8797-5a0282942ddc)
       ![image](https://github.com/lielocks/WIL/assets/107406265/ee68b22d-46b9-442a-adfd-c546f017464d)
