# 실행 파일을 만드는 과정을 자세히 살펴보자. '빌드 (build)'

### Build란 ?

먼저 빌드 과정 Build Process 가 뭔지 대략 알고 가보자 ! 


Build 라는 단어는 '무언가를 짓다' 라는 뜻이다. 

예를 들어 건물을 짓는다고 치면 설계도 기반으로 기초공사를 하고 철근을 세우고, 벽을 세우고, 도색하고 
등등의 과정을 거쳐 집이 완성되는 과정을 짓는다고 하는 것. 


프로그래밍도 마찬가지이다 ! 


컴퓨터는 근본적으로 0과 1 밖에 모른다. 


Java, C, C+= 등의 고급언어는 결국에 컴퓨터 (CPU)가 이해할 수 있도록 번역을 해줘야 한다. 

컴퓨터가 이해하는 언어를 기계어라고 하는데, 우리가 만든 source code가 컴퓨터 입장에서는 해외판 책이 되는 것이고, 
이 책을 기계어 (source code) 로 번역하여 컴퓨터에서 이해할 수 있는 즉 실행 가능한 파일로 만드는 과정을 **빌드(Build)**라고 한다. 


![image](https://github.com/lielocks/WIL/assets/107406265/fe6dd241-bd78-41f6-b2e3-c3305447905c)


정리하자면 우리가 만든 source code를 'build'라는 과정을 통해 실행 파일을 얻게 되는 것이다. 

그 실행 파일은 exe, exec 등 여러가지가 있다. 

이러한 실행 파일은 **기계어 (machine code)** 라고 언어 (CPU가 읽을 수 있는 이진코드) 로 이루어져 있다.


조금 더 세분화하여 살펴보자 ! 


### Build Process


앞서 빌드를 번역하는 과정에 빗대어 표현했다. 

 

외국어로 되어있는 책(source code)을 우리나라 말로 번역(build)하여 우리(machine)가 읽을 수 있는 책(실행 파일)으로 만드는 과정은 하나만 있는 것이 아니다.

예로들어 전문 번역가를 고용한다던지, 구글 번역을 사용한다던지, 파파고를 사용한다던지.. 여러 방식이 있다. 
이렇듯 컴퓨터의 build 과정도 모든 언어가 각기 다른 방식을 사용하고 있습니다.



빌드 과정은 크게 3가지 방식 
+ Compile 방식
+ Interpreter 방식
+ Hybrid 방식


  ![image](https://github.com/lielocks/WIL/assets/107406265/868484f2-efbd-465e-82b2-346d25719e42)



### 1. Compile Type

먼저 컴파일 타입이다. 


위 설명에서 보이듯이 우리가 작성한 source code를 한꺼번에 번역해서 실행파일로 만들어 준다.

한마디로 `통번역` !


이렇게 한번에 번역하는 언어들을 보통 Compile Language 라고 하는데 대표적으로 C, C++, Go 언어가 있다.


이러한 언어들의 빌드 과정은 대개 아래와 같다. 


![image](https://github.com/lielocks/WIL/assets/107406265/57feb801-f74f-40e1-9990-be5c4a8365c5)


위 그림을 보면 빌드 과정에 총 **4가지 단계**가 있다.


대부분 컴파일 언어가 위와 같은 과정을 거친다. 

그리고 화살표를 보면 두개로 나뉘다가 링크 작업에서 하나로 합쳐지는데, 이또한 의미가 있다.


책을 번역 할 때 만약 시리즈로 되어있는 책을 번역한다면 어떻게 번역할까? 각 단권별로 번역하고
그런 다음 하나로 묶어 책으로 발간을 할 겁니다.


이렇듯 각 파일 단위로 번역과정을 거친다음 최종적으로 하나로 묶게 되기 때문에 이해하기 편하게 화살표로 그 과정을 그려놓았다.



#### [preprocessing (전처리)]

전처리 (preprocess) 과정이다. 


단어를 보면 pre + process 대개 전처리라고 하지만 좀 더 쉽게 풀면 '사전 처리' 라고 보면 된다. 


전처리 과정은 **전처리기(preprocessor)** 에 의해 source code 에 포함 된 매크로나 지시자 같은 것을 포함시켜준다. 

>
>'소스 코드의 중심 (main) 이 실행되기 전에 사전준비 하는 과정'


앞서 빗대어 표현했던 책 번역과정으로 치자면 저자 이름, 책에서 정의하는 표현, 판권, 인용 등 이미 정해져 있는 것들을 먼저 처리하여 이후에 일일이 다시 찾아 쓸 필요 없이 정리해두는 과정이랑 비슷하다.


프로그래밍 언어로 보자면 C언어나 C++ 에서 # 으로 시작하는 구문들(#include, #define 등)이다.


#### [compilation (컴파일)]


우리가 프로그래밍 언어를 다루면 가장 많이 듣는 단어 중 하나이다. 

compile 이라는 뜻이 '번역하다'라는 뜻이다. 

흔히 컴파일을 소스코드를 실행파일로 만드는 것으로 생각하는 분들이 있는데, 엄연하게는 다르다!! 

말 그대로 '번역'하는 것일 뿐 `번역 된 것만으로는 컴퓨터가 실행 할 수는 없다.`


(외국어책을 번역만 해놓고 책으로 묶지 않으면 그 건 책이 아니라 그냥 번역만 한 종이일 뿐~)



우리가 대개 쓰는 eclipse, Visual Studio, X Code 같은 통합개발환경

(IDE : Integrated Development Environment)들은 대부분 한 번 컴파일(또는 빌드)을 하면 실행파일까지 나와버리기 때문에 오해하는 것이 아닌가...



어떤 언어로 번역하느냐. 컴파일 하는 프로그램을 **컴파일러(compiler)** 라고 한다. 


한마디로 번역가 ! 


컴파일러가 컴파일 하면 바로 기계어(Machine Code)로 번역 될 것 같지만 NO! 
흔히 중간언어 또는 저수준 언어라고 번역된다. 

보통은 어셈블리어(Assembly Language)로 번역된다.


왜 기계어로 바로 번역하지 않고 저수준 언어(low-level Language)로 번역되는지? 


이유는 프로그래밍의 역사를 보면 쉽게 알 수 있는데, 과거에는 0과 1로만 작업을 했어야 하다보니 여간 불편하기 짝이 없었다. 

예로들어 'A'라는 문자를 표현하려면 1000001 이런식으로 했었어야 하다 보니 이런 것들을 부호화(Symbolic) 한 것이다. 
단순히 부호화만 했기 때문에 기계어(Machine Code)와 1대1 매칭이 된다. 


그렇다 하더라도 우리가 사용하는 Java, C 같은 고급언어처럼 사람이 읽기 쉬운 언어가 아닌 난해한 언어인지라 저수준 언어(low-level language)에 속하게 되는 것이다.

저수준 언어의 장점으로는 내부가 어떻게 작동하는지 바로 볼 수 있다는, 즉 하드웨어를 직접적으로 조작하거나 특수 프로세서 명령어에 접근 등을 확인하거나 작업을 할 수가 있다는 것이다.

 
 한마디로 인간이 `기계어`를 이해하기 위해 `고급언어와 기계어 사이에 중간단계`인 `저수준 언어`로 번역하는 것이다. 
 

#### [assemble (어셈블)]

앞서 compile 단계에서 compiler 가 고급언어를 저수준 언어로 번역해주었다.


그러면 이 저수준 언어(어셈블리어) 를 최종적으로 기계어로 번역해주어야 한다.


이 `어셈블리어`를 `기계어`로 번역해주는 프로그램을 **에셈블러 Assembler** 라고 한다. 


이렇게 CPU가 이해할 수 있는 언어로 번역된 파일을 보통 Object File 이라고도 하는데, 직역하면 '객체 파일'이라고 하지만, 대부분은 객체라 하지 않고 **'목적 파일'** 이라고 한다 !


>
>'객체'
> 동작의 주체가 누군지 분류하여 동일성을 갖는 기능들을 하나의 묶음으로 만들어낸 하나의 실체


즉, 자판기라는 객체는 음료를 갖고 있고,

일정 값어치의 돈을 받으면 그에 대응하는 음료를 반환해주는 하나의 실체이듯, 

어셈블리어에서 기계어로 번역된 Object File 은 앞서 설명했듯 여러개의 관련된 파일을 빌드하면 

'링크' 단계 전까지는 각 파일별로 번역되기 때문에 `그 번역된 파일 하나하나가` 실행하는 최종 파일의 일부분으로서의 `객체`가 된다고 보면 된다. 


**그래서 Object 라는 단어가 붙게 되는 것** 


그리고 컴파일 과정을 여기까지 포함하기도 한다. 


Compile 이라는 단어 자체가 번역이라는 의미인데 이걸 프로그래밍에서는 크게 2가지로 해설할 수 있따. 


좁은 의미로는 'source code를 저수준 언어로 변환해주는 과정'


근데 조금만 더 생각해보면 assemble 도 번역하는 단계이다. 즉, compile 이라고 볼 수도 있다는 것 !


그래서 조금 더 넓은 의미로는 전처리 과정부터 어셈블 과정까지 compile 단계라고 하기도 한다. 


(또한 컴파일 언어의 빌드 과정에 어셈블이 없다면, 즉, 어셈블리어 같은 저수준 언어가 아닌 바로 
기계어로 번역되는 경우는 어셈블 과정이 생략되고 컴파일 단계만 있겠죠 ? )



#### [linking (링크/ 링킹)]


compile(assemble 포함) 과정을 통해 각 파일들이 기계어로 번역되었다면 이제 하나로 연결해주어야 한다 !


책을 번역할 때도 각 낱장별로 번역된 종이들을 하나로 모아 묶어야 책이듯, 각각의 Object File 은 기계가 이해할 수 있는 번역본일 뿐 실행 할 수 있는 파일이 x. 


즉, Object File 들과 필요한 라이브러리들을 연결 시켜주고 최종적으로 하나의 'executable file (실행가능한 파일)' 로 만들어준다. 

우리가 흔히 어떤 프로그램을 사용할 때 .exe 라는 확장자를 갖는 파일을 실행시킨다. 

이 `exe`가 바로 `exectuable` 의 줄임말 !


전처리 - 컴파일 - 어셈블 - 링크 4단계를 살펴보았다. 


포괄적으로 보면 **'전처리-컴파일-어셈블'** 단계를 하나의 컴파일 단계라고 본다고도 했다.


즉, build 와 compile 의  차이점이 여기서 나온다는 것이다. 

>
>compile 은 번역하는 단계로 소스코드를 목적 파일(Object File)로 만들어주는 과정일 뿐 그 결과물이 실행파일인 것은 아니다.
>
>
>이 컴파일 단계에 링크 과정 linking 이 포함 되어야 즉, build 가 비로소 실행가능한 파일이 나오는 전체 과정을 의미하는 것이죠.

아주아주 쉽게 말하면 **'컴파일 + 링크 = 빌드'** 라고 이해하시면 됩니다.



#### 컴파일 언어의 장점

1. 빌드가 완료된 실행가능한 파일은 실행 속도가 빠르다.

2. 매번 번역할 필요 없이 실행 파일만 실행하면 되기 때문에 전체적인 시간면에서 효율적


#### 컴파일 언어의 단점

1. 프로그램을 수정해야 할 경우 처음부터 빌드과정을 다시 거쳐야 하기 때문에 특히나 대규모 프로그램에서는 생산성이 low..

2. 플랫폼에 매우 의존적


플랫폼에 매우 의존적 -> window 실행파일을 macOS에서 실행하지 못하는 상황 떠올리면 됨


크게 두가지 원인 !

+ 어셈블리어의 경우 CPU 명렁어 세트 1대1 로 매칭된다. 즉 CPU에 의존적이라는 것인데 CPU 명령 체계가 거의 비슷하긴 하나 완전히 같지는 않다 !
+ 그리고 CPU가 이해할 수 있게 번역하여 최종 실행파일로 만들기 위해 링크라는 작업을 해주었는데, 이 과정에서 OS마다 서로 다른 라이브러리가 있어 linker는 해당 OS에서 요구하는 라이브러리를 연결하게 된다.



이러한 이유 때문에 우리가 프로그램을 내려받을 때 윈도우용, 맥용, 64bit, 32bit 등 이렇게 각 버전에 맞는 프로그램을 깔아야 하는 것 ~




### 2. Interpreted Type 


인터프리트 타입 source code를 통번역 하는 것이 아닌 한 명령 단위로 해석하면서 즉시 실행하는 방법이다.

좀 더 쉽게 생각하면 통역사를 떠올리자 !


![image](https://github.com/lielocks/WIL/assets/107406265/a0f458a4-027f-4d20-b66a-2032bb5b8bb5)


위 그림에서 컴파일 언어와 인터프리터 언어의 가장 큰 차이점을 보자면 ?!!


바로 목적파일 (Object File) 을 생성하지 않고 바로 direct 실행된다는 것이 가장 크다. 


보통 이러한 interpreter 언어에 가장 대표적인 언어는 JavaScript, Python, Ruby 가 있다.
( 이는 정확히 말하면 반은 맞고 반은 틀림. 이따 하이브리드 언어에서 설명하겠음)



쉽게 말하면 source code의 한 명령 세트마다 기계어 (Machine code) 로 번역하면서 바로바로 실행해주는 방식을 interpreter 라고 한다. 


그리고 이렇게 번역해주는 프로그램 (또는 환경) 을 **Interpreter(인터프리터)** 라고 한다.


즉. 각 운영체제에 맞는 해당 언어의 interpreter만 설치한다면 어느 운영체제에서든 해당 언어를 사용하더라도 동일한 결과를 얻을 수 있는 것 !

>
>한마디로 플랫폼에 독립적이다
>


또한 이렇게 compile 과정 없이 interpreter 를 통해 바로 결과를 볼 수 있기 때문에 프로그램 수정에 매우 유리하다는 장점이 있다.



그럼 실행 가능한 파일은 없는걸까 ? 라고 생각할수도 있겠지만 


source code 그 자체가 실행가능한 파일이 되는 거라고 이해하면 된다. 다만, source code 를 **번역해줄 수 있는 interpreter** 를 설치해야 된다.



#### interpreter 언어의 장점


1. 컴파일 과정 없이 바로 실행하기 때문에 수정, 디버깅에 유리하다. 즉 개발속도에 유리 !

2. 각 플랫폼에 지원하는 interpreter 만 있다면 실행 가능하기 때문에 플랫폼에 독립적 !



#### interpreter 언어의 단점

1. build 되어있는 compile 언어 프로그램보다 실행시간이 느리다.

2. 코드를 열면 다 보이니까 보안상 좋지 X



반대로 compile 언어에 비해 매번 부분씩 번역해야 하기 때문에 실행속도는 느리다는 단점이 있다.


하지만 이마저도 요즘 hardware 의 스펙이 높아지니까 일반 사람들에게는 compile 언어랑 interpreter 언어랑 실행 차이 체감하기 힘들정도라 

오히려 개발 속도가 빠른 interpreter 방식을 혼합하여 적용하려는 경향이 많아졌다 .




### 3. Hybrid Type


하이브리드 타입. 컴파일 방식 + 인터프리트 방식 혼합된 방법 



그럼 왜 혼합을 했을까 ?


compile 언어 단점 -> 실행 가능한 파일이 플랫폼에 의존적이라는 거지만 실행속도가 빠름


interpreter 언어 단점 -> 실행 속도는 느리지만 플랫폼에 독립적이라 어느 플랫폼이든 번역기 (interpreter) 만 있으면 실행 가능 



이 둘의 단점을 상호 보완하여 만들어진 것이 `hybrid type` !!



흔히 **'바이트 코드 언어 (Byte Code Language)** 라고 한다. 가장 대표적인 언어 :: Java



책을 번역하는 과정에 비유해서 들어보자면 이렇습니다. 세계적으로 가장 많이 쓰이는 언어는 영어이다 

영어가 모국어가 아닌 국가라 하더라도 영어를 할 줄 아는 사람들이 많아서 프랑스어, 힌두어 등등 다른 국가의 언어로 번역된 것을 1차적으로 영어로 번역을 해둔다. 

그런 다음 영어로 번역된 것을 한국어로 번역하면 번역 가능한 사람이 많은 만큼 쉽고 빠르게 번역할 수 있을 것이다.

영어는 어디서든 대부분 쓰기 때문에 조금은 번거롭더라도 `중간 번역과정을 한 번 거쳐두면` 그 다음부터는 재사용을 하기도 쉽고 다른 언어로 번역하기도 쉽다는 장점을 살린 것처럼 
프로그래밍에서도 이를 적용한 방식이 바로 하이브리드 방식이다. 



어디서든 대부분 쓰일 수 있다는 것을 해석하자면 플랫폼에 대해 독립적이라는 말이겠죠?




그림을 보기 전에 잠깐 설명하자면 고급 언어로 작성된 소스코드를 바이트 코드(bytecode)로 변환한다. 

**바이트 코드**란 일종의 `중간 언어`라고 생각하면 된다. 그리고 VM(Virtual Machine : 가상머신) 이라는 프로그램에 의해 바이트코드를 기계어로 바꿔준다.

>
>이 때 중요한 것은 바로 VM인데 VM은 하나의 프로그램이라고 생각하면 된다.


아주아주 쉽게 생각하자면 프로그램을 VM이라는 가상머신에서 실행한다고 보면 된다. 


즉, 각 플랫폼에 맞는 VM들이 만들어져 있다면 우리는 같은 source code 를 어느 플랫폼에서든지 동일한 결과를 얻어낼 수 있다는 것이다. 


![image](https://github.com/lielocks/WIL/assets/107406265/203f2a29-8695-46ec-a0fd-e33d6a100f59)

 
여기서 실행 가능한 파일은 ? 바로 Byte Code !


먼저 **Byte Code** 는 가상 머신 (Virtual Machine) 이 이해할 수 있는 **중간언어 Intermediate Language** 라고 보면 된다.

앞선 비유에서는 '영어'라고 보면 되는데 예를 들어 Java 를 compile 하면 .class file 이 생성된다. 

byte code는 기계어는 아니지만 어셈블리어처럼 '기계어에 조금 더 가까운 언어' 로 되어 있다.


다만 compile 언어의 목적 파일과 차이가 있다면 compile 언어에서는 하드웨어에 의해 처리되는 기계어로 되어 있었다면, byte code 파일의 경우 하드웨어가 직접 처리 X 
소프트웨어 (가상 머신) 에 의해 처리된다. 


역으로 생각해보자면 byte code는 해당 VM 전용 기계어라고 보면 된다. 



마지막으로 **VM!**


Virtual Machine의 줄임말인데 쉽게 생각해서 가상 컴퓨터라고 보면 된다. 
하나의 컴퓨터 환경을 구현했다고 생각하면 이해하기 좋음 



byte code는 이 가상 머신이 이해할 수 있는 코드!


그리고 그 가상 머신 안에는 interpreter 같은 해석기가 있어 이들이 byte code를 해석하여 각 OS에 맞게 명령어를 해석하고 작동하는 하나의 프로그램이라고 보면 된다.


쉽게 Java 를 예로 들면 java source code를 compile 하면 -> .class 파일이 나옴

이 파일만 있으면 JVM 이 설치된 어느 컴퓨터에서든 실행 할 수 있을 뿐만 아니라 거의 동일한 결과를 내보인다. 


가장 대표적인 VM : JVM 
C#의 경우는 .NET의 CLR 이 있다.


이들의 장점은 VM이 해당 운영체제에 맞게 지원만 해준다면 플랫폼에 독립적으로 실행할 수 있다는 장점이 있다.


인터프리터와 같은 원리 !


(물론 VM이 인터프리트만 하는게 아니라 최근에는 compile 방식과 혼용하여 구현되어 있다. 대표적으로 JIT Just-In-Time 이 있다)



즉 VM 을 통해 **'플랫폼에 독립적'** 인 장점을 갖고 왔고,


초기 컴파일 단계를 통해 **byte code** 로 기계어에 더 가까운 언어로 번역을 한 번 해놓았기 때문에 속도도 기존 interpreter 언어에 비해 더 빠르다는 정점 또한 갖고오게 된 것 !




#### 하이브리드 언어의 장점

1. 각 플랫폼에 지원하는 VM 이 있다면 실행 가능하기 때문에 플랫폼에 독립적 !


#### 하이브리드 언어의 단점

1. compile 언어처럼 하드웨어를 직접 제어하는 작업은 불가능 ..


---


### 정리하기


+ 주의해야 할 점 : C언어 = 컴파일언어, Python = 인터프리트언어 이런식으로 생각하면 '절대' X !


어디까지나 '대표적인' 언어일 뿐이지 **1대 1로 매칭되는 개념이 아니라 빌드 과정의 구현의 차이** 일 뿐 ~


언어는 어디까지나 언어고 이를 기계어로 바꾸는 수단은 엄청 많음 .



예로들어 C나 C++ 전용 interpreter(인터프리터)를 사용하여 인터프리트처럼 사용할 수 있고, python 코드를 JVM 에서 실행할 수 있도록 할 수도 있다.


우리가 책을 번역하는 것에 비유하면서 작성을 했는데, 책을 번역하는 방식이 꼭 한 가지만 있는 것이 아닌 것처럼 각 프로그래밍 언어들도 한 가지 방식으로만 빌드할 수 있는 것도 아니라는 것 !

 
