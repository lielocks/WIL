# 명령어 사이클


프로그램은 수많은 명령어로 이루어져 있고 CPU는 이 명령어들을 하나씩 실행한다. 


이때 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데 이 주기를 명령어 사이클 Insturction Cycle 이라고 한다. 


즉 프로그램 속 각각의 명령어들은 명령어 사이클이 반복되며 실행한다. 



### 01 인출 사이클 Fetch Cycle

**메모리에 있는 명령어를 CPU 로 가져오기**

![image](https://github.com/lielocks/WIL/assets/107406265/b5fa7a08-0590-4322-b642-b1f90781d7a7)




### 02 실행 사이클 Exectution Cycle

**CPU로 가져온 명령어를 실행, 제어장치가 명령어 register 에 담긴 값을 해ㅓㄱ하고 제어 신호를 발생시키는 단**


![image](https://github.com/lielocks/WIL/assets/107406265/780b70d3-ffaf-4672-98dc-1b30122625b7)


이렇게 프로그램을 이루는 수 많은 명령어는 인출과 실행 사이클을 반복하면 실행된다. 



![image](https://github.com/lielocks/WIL/assets/107406265/ac22b0af-9e28-4c56-a3a0-a26772695e76)



### 03 간접 사이클 Indirect Cycle


명령어를 인출하여 CPU로 가져왔다 하더라도 곧바로 실행할 수 없는 경우도 있다. 


간접 주소 지정방식을 떠올려보자 ! 


operand 필드에 유효 주소의 주소를 명시한다고 했다. 이 경우 명령어를 인출하여 CPU 로 가져왔다 하더라도 바로 실행 사이클에 돌입할 수 X.


명령어를 실행하기 위해서는 메모리 접근을 한번 더 해야하기 때문 !



![image](https://github.com/lielocks/WIL/assets/107406265/e020b826-4fdf-4477-bd52-34eb803e3265)



### 인터럽트 Interrupt


**CPU의 정상적인 작업을 방해하는 신호**



### 01 동기 인터럽트 Synchronous Interrupts , 예외


CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을때 예를 들어 프로그래밍상의 오류와 같은 예외적인 상황이 마주쳤을떄 발생 !

![image](https://github.com/lielocks/WIL/assets/107406265/3fca88f4-6f57-4ece-87ac-cf763bda2601)




### 02 비동기 인터럽트 Asynchronous Interrupts 하드웨어 인터럽트 


입출력 장치에 의한 비동기 인터럽트는 `세탁기 완료 알림`과 같은 `알림 역할`을 한다.

그렇게 된다며 입출력 작업 동안 CPU 는 다른일을 할 수 있다.


예를 들어 CPU가 프린터와 같은 입출력 장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력 장치가 CPU에 완료 앎림 (인터럽트) 를 보낸다. 


![image](https://github.com/lielocks/WIL/assets/107406265/c8ad348d-2ac9-4f1c-a23c-9b6c11fa5ad7)




### 하드웨어 인터럽트의 처리 순서


1. 입출력 장치는 CPU에 인터럽트 요청 신호를 보낸다.

2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.

3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들을 수 있는지 여부를 확인한다.

4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.

5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.

6. 인처럽트 서비스 루틴 실행이 끝나면 4에서 백업해둔 작업을 복구하여 실행을 재개한다.






## 인터럽트 용어


### 01 인터럽트 요청 신호


CPU는 정상적인 실행 흐름을 끊는 것이기에 다른 누군가가 인터럽트 하기 전에 끼어들어도 되는지 CPU한테 물어봐야 함.


### 02 인터럽트 플래그 interrupt flag


하드웨어 인터럽트를 받아들일지 무시할지 결정하는 플래그이다.


방해를 받고 싶지 않다면 0 불가능 으로 설정되면서 인터럽트 요청을 무시한다.


![image](https://github.com/lielocks/WIL/assets/107406265/4fce52e3-2057-4ba6-9c20-2701d3449c4f)


하지만 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 X.

막을 수 있는 인터럽트 maskable interrupt 와 막을 수 없는 인터럽트 non maskable interrupt 가 있다.


가장 먼저 처리해야 하는 인터럽트를 말한다. -> 하드웨어 고장 or 정전 ...



### 03 인터럽트 서비스 로틴 ISR , Interrupt Service Routine 인터럽트 핸들러 Interrupt Handler


CPU가 인터럽트를 받아들이기로 했다면 CPU는 인터럽트 서비스 루틴이라는 프로그램 실행.


이는 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램이다. 

ex 마우스가 어떤 인터럽트 요청을 보냈을떄 어떻게 작동한다.


![image](https://github.com/lielocks/WIL/assets/107406265/7562fb2c-aca0-410f-abc7-cd612272680f)



### 04 인터럽트 벡터 


CPU는 수 많은 서비스 루틴을 구분하기 위해 벡터를 사용한다. 


인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴의 시작 주소부터 실행 가능 !


---

*인터럽트 서비스 루틴은 여느 프로그램과 마찬가지로 명령어와 데이터로 이루어져있다. 프로그램 카운터를 비롯한 register 들을 사용하며 실행된다.*


**인터럽트가 발생하기 전까지 register 에 저장되어 있었던 값들은 어떻게 해야 할까 ?**


인터럽트 요청을 받기 전까지 CPU 가 수행하고 있었던 일은 인터럽트 서비스 루틴이 끝나면 되돌아와서 마저 수행을 해야하기 때문에 지금까지의 작업 내역들은 어딘가에 백업을 해두어야 한다.


그렇기 때문에 CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 stack 에 백업한다. 


그리고 나서 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 인터럽트 서비스 루틴을 실행한다. 

---


### 최종 명령어 사이클 



![image](https://github.com/lielocks/WIL/assets/107406265/bce2ae66-d710-46ee-8c97-d28c23c6b9ec)
