## Node.js

웹의 역사에서부터 천천히 출발해보자.

1990년 Tim Berners lee 가 WEB 을 창시했다.

이때의 웹은 정적인 체계의 웹이였다.
  
Marc Andreessen 에 의해  Netscape 라는 대중적 웹브라우저가 등장하게 되었고

Brendan Eich 에 의해 JavaScript 등장하고 웹에 동적인 체계를 탑재하게 되었다.
  
즉, 사용자와 상호작용이 가능해졌다는 이야기이다.

WEB 이라는 울타리안에 갇혀있던 JavaScript, 대중성을 중시해서 천대 받던 JavaScript 가 재조명 받게되는 계기가 있었다.

<br>


**2004 년, Gmail 등장이다.** 
  
순수한 웹기술(HTML, JavaScript 등)을 통해서 만들었음에도 불구하고 뛰어난 성능을 보인 것이다.

이어서 GMap 도 순수 웹기술로 구축되었고 이 또한 개발자들에게 신선한 충격을 주었다.

이 후로 자바스크립트의 성장세는 계속된다.

2008년 구글이 Chrome의 성능 향상을 위해 JavaScript Engine 개발하였다.

그것이 V8 이고 이것을 오픈소스로 공개하여 수많은 개발자들을 이끌었다.

그리고 2009년 Ryan Dal 이 *JavaScript 언어로 구현된 서버 사이드 언어 Node.js* 를 내보인다.

그렇다면,

***Web Browser 에서 작동하는 JavaScript와 Node.js 차이는 무엇인가 ?***

<br>

JavaScript 라는 단어에는 두가지의 의미가 혼재되어있다.

**`language`** 로서의 JavaScript 와 

**`Run Time(언어가 작동하는 환경)`** 으로의 JavaScript 이다.

프로그래밍 세계에서 잠깐 벗어나서 실생활의 구체적인 예로 접근을 해보자.

JavaScript 언어를 '한국어(일상 우리가 사용하는 언어)'라고 한다면 그 한국어를 통해서 병원엘 가거나 법원에 가는 등에 가서 일을 처리할 수 있다.

즉, JavaScript 란 프로그래밍 언어로 Web Browser 를 제어하거나 서버를 제어할 수 있다.

<br>

둘 다 JavaScript 의 문법을 기반으로 한다. 하지만 다른 함수를 사용한다.

예를 들면 alert 라는 함수는 Only Web 에서 작동하는 함수이며 서버에서는 사용할 수 없다.

alert 이란 함수는 *Node.js 라는 runtime 에는 없는 함수* 라는 말이 된다.

Node.js 에 alert 이라는 명령어를 입력하는 것은 법원에 가서 아프니까 약달라고 하는 꼴이다.

<br>

그러므로 JavaScript 라는 언어만 안다고 두 가지를 모두 제어할 수 있는 것이 아니라 각각이 어떠한 기능을 가지고 있는지 알고 있어야 제어가 가능하다.

병원이 뭘 하는 곳인지, 어떤 기능을 갖고 있는지 알아야 하는 것처럼 말이다.

Node.js 공부의 시작은 어떠한 기능들이 있는지 알아가는 것이다.

Web과 Node.js는 서로 협력적인 관계이다.

이 두 가지를 제어해서 하나의 완결된 웹 애플리케이션을 만들 수 있다.

<br>

Node 와 비슷한 언어는 어떤 것이 있을까, 경쟁자라고도 할 수 있겠다.

= 파이썬 루비 PHP Java ... ?

그렇다면 이 경쟁자들과 비교해서 Node.js의 장점은?
이 많은 언어 중에 Node.js 를 선택한 개발자가 얻는 장점은 무엇이란 말인가?

<br>

![image](https://github.com/lielocks/WIL/assets/107406265/539b635f-e29b-4fac-8c84-e6ca1947b1ee)

**1. V8 Engine 이다.**

구글이 망하지 않는 한 이 engine 은 끈임없이 개선되고 발전할 것이며 지금도 충분한 성능을 보이고 있지만 추후 더 훌륭한 퍼포먼스를 보일 것으로 예상된다.

<br>

**2. Event - driven 방식**

*사용자가 event 를 발생시켰을 때* 즉, 입력장치로 데이터를 전송했을 때'에만' 작동하는 방식이다.

발생한 event 에 대해서만 웹 서버가 **'연결'** 을 해주기 때문에 자원을 최소화할 수 있다.

대부분의 웹 서버는 사용자가 이벤트를 발생하기까지를 기다리면서 '자원'(대기시간 / 메모리)을 계속 소비하게 된다.

<br>

**3. non - blocking 패러다임**

non - Blocking I/O 을 이해하기 위해서 우선 Blocking I/O 방식을 이해하자.

Blocking I/O 방식(동기식 I/O) 은 Read/Write 이벤트가 발생하면 이벤트가 끝날때까지 해당 모듈을 점유하게 된다. 즉 다른일을 못하게 된다.

또한 memoery buffer 에 데이터를 차지하게 되므로 memory 도 소비하게 된다.

요청한 I/O(DB,File,Network) 가 완료될 때까지 해당 Thread 를 '대기 모드'로 전환 시켰다가 요청한 I/O 완료 후 유저코드를 실행시킨다.

<br>

Blocking 방식의 비효율성을 극복하고자 만들어진 것이 Non-Blocking 방식이다.

I/O 작업을 진행하는 동안 유저 프로세스의 작업을 중단시키지 않는다.

Non-Blocking I/O(비동기식 I/O) 의 경우 **Read/Write 이벤트가 시작하자마자 모듈을 변환시켜 다른 작업을 하도록 준비상태가 된다.** 

그래서 속도가 동기식보다 빠르고 메모리도 덜 차지하게 된다.

적합한 경우에는 굉장히 빠른 퍼포먼스를 보이고 적재적소에 이 방식을 사용하면 퍼포먼스가 크게 향상할 수 있다.

<br>

**4. Single Thread**

Nodejs 자체는 Multi thread 이다.

Javascript engine 에는 외부 요청(입력) 에 대한 처리를 하는 단일 호출 스택이 존재하는데, 

이 단일 호출 스택과 Node.js 의 다양한 thread 를 연동하기 위해 사용하는 장치가 **event loop** 이며,

이 **event loop 가 Single Thread** 인 것이다.

+ **장점**

  + 수 많은 요청에 대해 순차적으로 처리할 필요 없이 worker thread 에 작업 처리를 위임하고, 작업이 끝나는 순서대로 이벤트를 받아서 응답한다.
  => 대규모 네트워크 프로그램을 개발하기에 적합

  + 요청의 수와 상관 없에 main thread 는 하나이기 때문에 메모리 사용량과 시스템 리소스 사용량에 변화가 거의 없다.
 
  + 따라서 서버에 부하가 적다. (가볍다)

<br>

+ **단점**

  + Context Switching 비용이 크다.
 
  + 많은 요청을 처리하기엔 적합하지만, 큰 단일 처리가 필요한 요청에는 적합하지 않다. (Callback 지옥에 빠질 수 있음)
 
  + Main thread 가 무너지면 program 전체에 문제가 갈 수 있다.


<br>


## Node.js 로 만드는 server

### 작고 빈번한 요청을 처리하는 서비스에 어울린다

+ Single Thread 이기 때문에 하나의 커다란 요청보다 간단한 요청 처리에 어울린다

+ 예를 들어 network streaming , 채팅 등 작고 빈번한 요청의 서비스들.

+ 또한 비동기로 요청을 처리하기 때문에 처리가 끝나면 바로 응답한다. 즉, 응답 속도가 빠르다

+ 심지어 **`async, await`** 의 등장으로 비동기 처리 로직을 작성하는 난이도도 쉬워졌다.

<br>

### 로직이 간단한 서비스

+ Nodejs 는 runtime 에 에러가 발생할 수 있기 때문에 프로그램 복잡도와 위험도가 비례한다.

+ 또한 서버에 체크 로직이 많으면 callback 지옥에 빠질 수도 있다. (async, await 로 어느정도 해결 가능!)

+ Node.js 가 원인을 알 수 없는 이유로 종료되는 경우는 없다. 주로 예외처리를 하지 않은 개발자의 실수가 원인이기 때문에, 개발복잡도가 올라가면 실수할 가능성이 높아진다.

<br>


### 빠르게 개발해야 할 때

+ NPM 생태계에서 다른 패키지 도움을 받아 개발 효율을 높일 수 있으며 개발 환경 자체가 그리 복잡하지 않기 때문에 빠르게 개발을 진행할 수 있다.

+ 웬만한 기능은 이미 NPM package 에 존재한다.

<br>


### 데이터 포맷으로 JSON 을 사용할 때

+ Javascript 자체가 **JSON** 을 지원하기에 적합하다.

+ Database 로 **MongoDB / Elasticsearch** 등을 사용한다면 시너지가 더 발생한다.
