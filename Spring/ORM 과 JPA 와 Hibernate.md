# 1. JPA (Java Persistent API) 와 ORM (Object Relational Mapping)

JPA 란 **자바 ORM 기술에 대한 API 표준 명세*** 를 의미합니다.

JPA 는 **`ORM 을 사용하기 위한 인터페이스를 모아둔 것`** 이며, 
JPA 를 사용하기 위해서는 JPA 를 구현한 `Hibernate, EclipseLink, DataNucleus` 같은 ORM 프레임워크를 사용해야 합니다.

![image](https://github.com/lielocks/WIL/assets/107406265/54ae2545-a890-4343-b1a3-5867a79cfb43)

### ORM

그렇다면 ORM 은 무엇일까요?

**ORM** 이란 **`객체와 DB의 테이블이 매핑`** 을 이루는 것을 말합니다. (Java 진영에 국한된 기술은 아닙니다.)

즉, **객체가 테이블이 되도록 매핑시켜주는 것** 을 말합니다.

**ORM** 을 이용하면 SQL Query 가 아닌 **직관적인 코드(메서드)로서 데이터를 조작** 할 수 있습니다.

<br>

예를 들어, User 테이블의 데이터를 출력하기 위해서는 **`MySQL`** 에서는 `SELECT * FROM user;` 라는 query를 실행해야 하지만,

**`ORM`** 을 사용하면 User 테이블과 매핑된 객체를 user라 할 때, `user.findAll()` 라는 **메서드 호출** 로 데이터 조회가 가능합니다.

<br>

query 를 직접 작성하지 않고 메서드 호출만으로 query 가 수행되다 보니, ORM 을 사용하면 **생산성이 매우 높아집니다.**

그러나 **query 가 복잡해지면 ORM 으로 표현하는데 한계** 가 있고, 성능이 `raw query 에 비해 느리다` 는 단점이 있는데요,

그래서 나중에 다루게 될 `JPQL, QueryDSL` 등을 사용하거나 한 프로젝트 내에서 `Mybatis와 JPA를 같이` 사용하기도 합니다.

<br>

Java 에서 DB를 다룰 때, JDBC 를 직접 사용하는 것보다 Mybatis를 사용했을 때 코드가 간결해지고 유지보수가 편했다는 것을 느꼈습니다.

**Hibernate** 를 배우게 되면 Mybatis보다 코드가 더 간결하며, 더 객체 지향적이고 생산성이 매우 높다는 것을 느끼게 될 것입니다.

<br>

# 2. Mybatis vs Hibernate

JPA를 구현한 여러 프레임워크가 있지만 Hibernate가 JPA를 주도하고 있기 때문에 JPA를 Hibernate라 생각하고 혼용해서 사용하도록 하겠습니다.

먼저, 전 세계 개발자들은 Mybatis와 Hibernate 중 어떤 것을 더 많이 사용하는지 알아보겠습니다.

![image](https://github.com/lielocks/WIL/assets/107406265/4295bd8e-e5a1-4056-a0e3-c107ca79d3ff)

동아시아를 제외하고 대부분 나라에서는 **Hibernate** 를 압도적으로 많이 사용하고 있다는 것을 알 수 있습니다.

그만큼 `JDBC를 직접 사용하는 Mybatis` 보다 `JDBC를 노출하지 않고 ORM 기술을 사용` 하는 **`JPA`** 를 선호한다는 것을 알 수 있습니다.

( JPA도 분명 단점이 존재하기 때문에 서비스에 따라 Mybatis를 사용할 지 JPA를 사용할 지 결정해야 합니다. )


이제 JPA가 이렇게 인기가 많아지게 된 배경을 살펴보기로 하겠습니다.

<br>

# 3. JPA 탄생 배경

Mybatis에서는 테이블 마다 비슷한 CRUD SQL을 계속 반복적으로 사용했었습니다.

소규모라도 **Mybatis** 로 애플리케이션을 만들어 보셨다면, `DAO 개발이 매우 반복` 되는 작업이며, 이 작업이 매우 귀찮다는 경험을 해보았을 것입니다.

<br>

또한 테이블에 컬럼이 하나 추가된다면 이와 관련된 *모든 DAO의 SQL문을 수정* 해야 합니다.

즉, **`DAO와 테이블은 강한 의존성`** 을 갖고 있습니다.

<br>

이러한 이유로 SQL 을 자동으로 생성해주는 툴이 개발 되기도 했지만, 반복 작업은 마찬가지였고 큰 효과가 없었습니다.

그 이유는 **객체 모델링보다 데이터 중심 모델링 (테이블 설계) 을 우선시했으며,
객체지향의 장점(추상화, 캡슐화, 정보은닉, 상속, 다형성)을 사용하지 않고 객체를 단순히 데이터 전달 목적( VO, DTO )에만 사용했기 때문입니다.**

다시 말하면 객체지향 개발자들이 개발하고 있는 방법이 전혀 객체 지향적이지 않다는 것을 느끼게 된 것입니다.

아래의 모델링은 `Book` 과 `Album` 테이블의 공통된 컬럼인 `name과 price` 를 `Item` 이라는 테이블에 정의하여 상속받도록 한 **객체 지향 모델링(OOM)** 입니다.

![image](https://github.com/lielocks/WIL/assets/107406265/19c8c8a0-fd55-4150-97d4-436942892bb8)

ERD에서 사용하는 데이터 모델링과 달리 객체지향 모델링에는 **상속** 이라는 개념이 있습니다.

모델링을 위와 같이 객체 지향적으로 설계 했을 때, `SQL을 작성해야 하는 JDBC` 로 사용하기 위해서는 ERD로 다시 바꿔줘야 하는데 ERD에서는 상속 관계를 표현하기가 `까다롭습니다.`

<br>

그런데 객체 지향 설계에 대해서, **`상속 관계를 잘 표현 해주는 데이터 모델링`** 으로 바꿔주는 기술이 있다면?

그리고 상속 관계에 있는 테이블에 대해 **`Join`** 도 알아서 해결 해준다면 객체 지향적인 설계가 가능할 것입니다.

<br>

정리하자면 JDBC API를 사용했을 때의 문제는 다음과 같습니다.

+ 유사한 `CURD SQL` 반복 작업
  
+ 객체를 `단순히 데이터 전달` 목적으로 사용할 뿐, 객체 지향적이지 못함 ( 페러다임 불일치 )

그래서 **객체와 테이블을 매핑 시켜주는 ORM** 이 주목 받기 시작했고, 자바 진영에서는 ***JPA*** 라는 표준 스펙이 정의 되었습니다.

<br>

# 4. Hibernate 특징

Hibernate를 사용하면 위의 문제들을 해결할 수 있습니다.

그리고 항상 완벽한 기술은 없듯이 Hibernate에도 단점이 존재하는데, 지금부터 Hibernate의 장단점을 알아보겠습니다.

<br>

### 장점

1. **생산성**
   
+ Hibernate는 SQL를 직접 사용하지 않고, **메서드 호출만** 으로 쿼리가 수행됩니다.

+ 즉, SQL 반복 작업을 하지 않으므로 생산성이 매우 높아집니다.

  + 그런데 SQL을 직접 사용하지 않는다고 해서 SQL을 몰라도 된다는 것은 아닙니다.

  + Hibernate가 수행한 쿼리를 `콘솔` 로 출력하도록 설정을 할 수 있는데, 쿼리를 보면서 의도한 대로 쿼리가 짜여졌는지, 성능은 어떠한지에 대한 모니터링이 필요하기 때문에 SQL을 잘 알아야 합니다.

<br>

2. **유지보수**
   
+ `테이블 컬럼이 하나 변경` 되었을 경우,

  + Mybatis에서는 관련 DAO의 파라미터, 결과, SQL 등을 `모두 확인하여 수정` 해야 함

  + JPA를 사용하면 **JPA가 이런 일들을 대신** 해주기 때문에 유지보수 측면에서 좋습니다.

<br>

3. **특정 벤더에 종속적이지 않음**
   
+ 여러 DB 벤더( MySQL, Oracle 등.. )마다 SQL 사용이 조금씩 다르기 때문에 애플리케이션 개발 시 처음 선택한 DB를 나중에 바꾸는 것은 매우 어렵습니다.

+ 그런데 JPA는 **추상화된 데이터 `접근 계층` 을 제공** 하기 때문에 특정 벤더에 종속적이지 않습니다.

  + 즉, `설정 파일` 에서 JPA에게 어떤 DB를 사용하고 있는지 알려주기만 하면 **얼마든지 DB를 바꿀 수가 있습니다.**

<br>

### 단점

1. **성능**
   
+ 메서드 호출로 쿼리를 실행한다는 것은 `내부적으로 많은 동작` 이 있다는 것을 의미하므로, `직접 SQL을 호출` 하는 것보다 **성능이 떨어질 수 있습니다.**

+ 실제로 `초기의 ORM` 은 쿼리가 제대로 수행되지 않았고, 성능도 좋지 못했다고 합니다.

  + 그러나 지금은 많이 발전하여, 좋은 성능을 보여주고 있고 계속 발전하고 있습니다.

<br>

2. **세밀함**

+ **메서드 호출** 로 SQL을 실행하기 때문에 세밀함이 떨어집니다. 또한 **`객체간의 매핑( Entity Mapping )`** 이 잘못되거나**`JPA를 잘못 사용`** 하여 의도하지 않은 동작을 할 수도 있구요.

+ **복잡한 통계 분석 쿼리** 를 메서드 호출로 처리하는 것은 힘든 일입니다.

  + 이것을 보완하기 위해 JPA에서는 SQL과 유사한 기술인 `JPQL` 을 지원합니다.

  + 물론 SQL 자체 쿼리를 작성할 수 있도록 지원도 하고 있습니다.

<br>

3. **러닝커브**

+ JPA를 잘 사용하기 위해서는 알아야 할 것이 많습니다.

+ 그래서 이러한 복잡성을 해결하고자 최근에는 **`Spring Data JDBC`** 가 주목을 받고 있습니다. ( 2018-09-21 첫 1.0.0 RELEASE )

<br>

# 5. 정리

JPA가 SQL을 직접 작성하지 않는다고 해서 JDBC API를 사용하지 않는다는 것은 아닙니다.

**`Hibernate가 지원하는 메서드 내부`** 에서는 **JDBC API가 동작** 하고 있으며, 단지 개발자가 `직접 SQL을 직접 작성하지 않을 뿐` 입니다.

그래서 JPA에서 수행하는 쿼리가 내 의도대로 실행이 된건지 모니터링을 할 줄 알아야 합니다.

<br>

JPA는 통계 쿼리처럼 복잡한 SQL을 수행하기 힘들기 때문에, 비즈니스에 따라 `Mybatis` 를 사용할 지 `Hibernate` 를 사용할 지 상황에 맞는 선택이 중요할 것입니다.

처음에 살펴본 구글 트렌드를 볼 때 우리나라는 대부분 `Mybatis` 를 사용하고 있는데, 그 이유는 우리나라 시장 대부분이 `SI` , `금융 시장` 이기 때문입니다.

비즈니스가 매우 **복잡** 하고, 안정성을 중요시 하는 서비스일 경우에는 JPA보다 **SQL을 작성하는 것이 더 좋다** 는 의도일 것입니다.

이미 SQL을 사용하여 개발된 애플리케이션이라면 JPA로 바꾸는 일도 쉽지 않기 때문에, 우리나라에서는 JPA가 많이 사용되지 못하는 것 같습니다.

그런데 최근에는 `서비스 업체, 신규 프로젝트들` 은 **`JPA`** 를 많이 사용하고 있는 것 같네요.

<br>

ORM은 꾸준히 발전하고 있는 기술이며, 저는 높은 생산성을 자랑하는 ORM을 매우 좋아합니다.

처음 접한 프레임워크가 `Ruby on Rails` 였는데, `ROR에서는 ORM이 내장` 되어 있습니다.

그 영향인지는 몰라도 Node.js 공부할 때도 ORM이 있는지 먼저 찾았었네요.

역시나 `자바` 에서도 `Hibernate` 라는 멋진 기술이 있었습니다.





