## 트리 (Tree) 의 개념

트리는 노드로 이루어진 자료구조로 스택이나 큐와 같은 선형 구조가 아닌 비선형 자료구조이다.

트리는 계층적 관계를 표현하는 자료구조이다.

아래와 같은 특징들이 있다.

<br>

1. 트리는 하나의 root node 를 갖는다.

2. root node 는 0 개 이상의 자식 노드를 갖는다.

3. 자식 노드 또한 0개 이상의 자식 노드를 갖는다.

4. 노드 (node) 들과 노드들을 연결하는 간선 (edge) 들로 구성되어 있다.

<br>

+ **트리에는 cycle 이 존재할 수 없다.** 여기서 사이클이란 `시작 노드에서 출발해 다른 노드를 거쳐 다시 시작 노드로 돌아올 수 있는 것.`

  ![image](https://github.com/lielocks/WIL/assets/107406265/5784ec0e-1c5f-4cf0-bbd4-b0c317328839)

+ 트리는 cycle 이 없는 하나의 연결 그래프 (Connected Graph) 라고 할 수 있다.

+ 트리의 노드는 self-loop 가 존재해서는 안된다.

![image](https://github.com/lielocks/WIL/assets/107406265/04e636ac-f87c-4991-9f04-19f2c8244df4)

+ N개의 노드를 갖는 트리는 항상 N-1 개의 간선 (edge) 를 갖는다.

+ 모든 자식 노드는 한개의 부모 노드만을 갖는다.

<br>

### 트리와 관련된 용어

![image](https://github.com/lielocks/WIL/assets/107406265/8031d64f-ccf8-4862-ade9-bbfe10a1bff6)

+ **루트 노드 root node** : 부모가 없는 노드로 트리는 **`단 하나의 루트 노드`** 를 가진다. (ex : A)

+ **단말 노드 leaf node** : 자식이 없는 노드로 terminal 노드라고도 부른다. (ex : D, E, C)

+ **내부 노드 internal node** : 단말 노드가 아닌 노드 (ex : A, B)

+ **간선 (edge)** : 노드를 연결하는 선

+ **형제 (sibling)** : 같은 부모 노드를 갖는 노드들 (ex : D-E / B-C)

+ **노드의 깊이 (depth)** : 루트 노드에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수 (ex : D 의 depth -> 2)

+ **노드의 레벨(level)** : 트리의 특정 깊이를 가지는 노드의 집합 (ex : level 1- {B, C})

+ **노드의 차수(degree)** : 자식 노드의 개수 (ex : B의 degree -> 2, C의 degree -> 0)

+ **트리의 차수(degree of tree)** : 트리의 최대 차수 (ex : 위 트리의 차수는 2 이다)

<br>

## 트리의 종류

### 1. 이진 트리 Binary Tree
이진트리는 각 노드가 **`최대 두 개의 자식`** 을 갖는 트리를 뜻한다. 
즉, **모든 노드들이 둘 이하(0,1,2 개)의 자식을 가진 트리이다.**  

![image](https://github.com/lielocks/WIL/assets/107406265/55e93ad2-dd04-4c53-999b-7ac72eeab636)

![image](https://github.com/lielocks/WIL/assets/107406265/7b6acc16-6585-4553-bb68-abde104a0b16)

이진 트리는 전위 순회, 중위 순회, 후위 순회를 통해 탐색할 수 있다.

<br>


### 2. 이진 탐색 트리 (Binary Search Tree, BST)

**왼쪽 자식은 부모보다 작고 오른쪽 자식은 부모보다 큰 이진 트리** 이다.

![image](https://github.com/lielocks/WIL/assets/107406265/be034f25-1cbe-4116-854a-ca4506bcf372)


1. 부모 노드의 왼쪽 노드는 부모 노드보다 작아야 한다.

2. 부모 노드의 오른쪽 노드는 부모 노드보다 커야 한다.
   
<br>

BST는 삽입, 삭제, 탐색과정에서 모두 트리의 높이만큼 탐색하기 때문에 **`O(logN)`** 의 시간 복잡도를 가진다.
문제는 `트리가 편향트리가 되어버렸을 때` 결국 배열과 다름 없어지고 시간 복잡도는 **`O(N)`** 이 된다.

중위순회(inorder traversal)를 하면, 오름차순으로 정렬된 순서로 Key값을 얻을 수 있다.

참고로 순회 종류는 아래와 같다.

+ **전위 순회 preorder traverse** : Root를 제일 먼저 순회 **`Root L R`**
    1. Root 출력
    2. Left child 출력
    3. Left leaf로 갈때까지 반복
    4. Root 출력후 Right child 기준으로 반복 (Right leaf로 갈때까지)

+ **후위 순회 postorder traverse** : Root를 제일 마지막에 순회 **`L R Root`**
    1. Left leaf 이동 및 출력
    2. Right child 출력
    3. Parent node 출력
    4. 위로 올라가며 반복
    5. Root 출력후 Right child 기준으로 반복

+ **중위 순회 inorder traverse** : Root를 중간에 순회 **`L Root R`**
    1. Left leaf 이동 및 출력
    2. Parent node 출력
    3. Right child 출력
    4. 한 레벨씩 위로 올라가며 반복
    5. Root 출력후 Right child 기준으로 반복

![image](https://github.com/lielocks/WIL/assets/107406265/1adb7497-637d-4c1a-9d40-260a2d72e224)


<br>


### 3. 완전 이진 트리 (Complete Binary Tree)

+ 완전 이진 트리 Complete Binary Tree

![image](https://github.com/lielocks/WIL/assets/107406265/8c9c515e-da92-4f67-994e-eac20f61eff5)

    
1. 완전 이진트리는 **마지막 레벨을 제외 하고 모든 레벨이 완전히 채워져 있다.**
   
2. 마지막 레벨은 꽉 차 있지 않아도 되지만, 노드가 왼쪽에서 오른쪽으로 채워저야 한다.
    
3. 완전 이진 트리는 배열을 사용해 효율적으로 표현 가능하다. 완전 이진 트리의 개념은 힙(heap)과 관련이 있다.

 
![image](https://github.com/lielocks/WIL/assets/107406265/c2401bbf-7d90-486d-b18d-3ca2e62dc5cb)

![image](https://github.com/lielocks/WIL/assets/107406265/4a667eb9-6868-4525-84b9-7bb453b579ee)
