# Database(DB)란?

데이터베이스를 한 마디로 정의하면 ‘데이터의 집합’이라고 할 수 있습니다.

데이터베이스에는 일상생활 대부분의 정보가 저장되고 관리됩니다. 

오늘 보내거나 받은 카카오톡 메시지, 인스타그램에 등록한 사진, 버스/지하철에서 찍은 교통카드, 카페에서 구매한 아이스 아메리카노 등의 정보가 모두 데이터베이스에 기록됩니다.

<br>

### 데이터베이스 관리 시스템의 구성

데이터베이스 관리 시스템은 기능에 따라 크게 질의 처리기와 저장 데이터 관리자로 구성되어 있다.

![image](https://github.com/lielocks/WIL/assets/107406265/ebe84912-2470-40ac-a214-7cc9a4b14251)


<br>

### Database 와 Storage 의 차이점

+ **Database**
  
  데이터베이스는 체계적인 데이터 모음으로 데이터 저장 및 조작을 지원한다.
  **`Storage 에 저장된 데이터`** 를 더욱 사용하기 쉽게 만들어주는 것이 **`데이터베이스 서버`** 라고 생각하면 된다.

+ **Storage**
  
  컴퓨터에 데이터를 저장하는 저장소의 역할을 수행하는 부품으로, 하드디스크와 동일한 역할을 수행하는 부품이다. ( 비휘발성 기억장치 )

  ![image](https://github.com/lielocks/WIL/assets/107406265/66cbd393-a5ab-4f44-90a4-bd27f348f212)

스토리지는 직접 서버에 연결할 수 있고, 대용량의 데이터를 저장하기 위해 별도의 스토리지용 네트워크를 구성할 수도 있다.

Storage 에도 종류가 다양하며 (DAS / NAS / SAN ), 연결 방식 등에 의해 구분된다.

Storage 는 hardware 기반의 장비이기 때문에 장비의 성능에 따라 혹은 안정성에 따라서 성능이 좌지우지된다.

<br>

### 차이점

**1. Physical vs Logical**

+ **Storage** : 파일 또는 물리적 저장소로 객체 스토리가 될 수 있다.

+ **Database** : 조직화된 데이터가 저장된 논리적 (Logical) 저장소이다.

<br>

**2. 관계**

Database 는 일종의 Storage 이다.

<br>

**3. 저장 데이터 종류**

+ Storage 는 텍스트파일, 이미지, 영상 등 다양한 종류의 데이터가 저장될 수 있다.

+ Database 는 Id, record, 거래 정보와 같은 구조적 또는 반구조적 데이터가 저장될 수 있다.

<br>

### 결론

Storage는 파일이 담긴다.

DB는 nosql 을 차치하고 일반적으로 2차원 데이터 형태인 칼럼 (column, field) 과 로우 (row, record) 로 구성되는 테이블형 데이터가 담긴다.

즉, Storage 는 파일 형태가 되면 무엇이든 담을 수 있지만 Database 에 담기 위해서는 앞단 또는 뒷단에서 가공해서 저장해야 한다. 


<br>


## DBMS 란?

데이터베이스를 ‘데이터의 집합’이라고 정의한다면, 
이런 **데이터베이스를 관리하고 운영하는 소프트웨어를 DBMS(Database Management System)** 라고 합니다.

다양한 데이터가 저장되어 있는 데이터베이스는 여러 명의 사용자나 응용 프로그램과 공유하고 동시에 접근이 가능해야 합니다.

가까운 예로 은행의 예금 계좌는 많은 사람들이 가지고 있습니다. 

여러 명의 예금 계좌 정보를 모아 놓은 것이 데이터베이스입니다. 

은행이 가지고 있는 예금 계좌 데이터베이스에는 여러 명이 동시에 접근할 수 있습니다. 

예금 계좌 주인, 은행 직원, 인터넷 뱅킹, ATM 기기 등에서 모두 접근이 가능하니까요. 

이러한 것이 가능한 이유는 바로 DBMS가 있기 때문입니다.

![image](https://github.com/lielocks/WIL/assets/107406265/8dfd43e8-74fd-4a6e-8631-26e92dd28c27)

<br>

### DBMS 구조

**DBMS와 같은 소프트웨어는 특정 목적을 처리하기 위한 프로그램** 입니다.

DBMS는 각 제품마다 구조가 다르기는 하지만, 크게 질의 처리기(Query Processor)와 저장 시스템(Storage System)으로 나눠볼 수 있습니다. 

MySQL의 경우에는 InnoDB, MyISAM 등과 같이 여러 하부 저장 시스템을 선택할 수 있는데, 이와 같은 모델은 상부의 질의 처리기와 하부의 저장 시스템 간의 명확하게 구분되는 계층(layered) 구조에 해당됩니다. 

CUBRID 역시 질의 처리기와 저장 시스템 두 개의 구성 요소로 이루어져 있으며, 질의 처리기와 저장 시스템이 좀 더 밀접하게 연결되어 있습니다.


데이터베이스는 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임으로, 최소의 중복으로 통합(integrated), 저장(stored)된 운영(operation) 데이터로 구성된다. 

`통합 데이터(integrated data)` 는 중복을 배제하나 경우에 따라 불가피하게 중복을 허용하는 데이터로, 이러한 의도적 중복은 항상 파악하여 관리할 수 있다. 

`저장 데이터(stored data)` 는 컴퓨터의 저장매체에 저장하여 관리하는 데이터를 의미하고, 

`운영 데이터(operation data)` 는 단순한 데이터의 집합이 아니라 그 조직의 기능을 수행하는 데 없어서는 안될 필수의 데이터를 의미한다. 

`공용 데이터(shared data)` 는 어느 하나의 응용프로그램이나 응용시스템을 위한 데이터가 아니라, 그 조직의 여러 사용자와 여러 응용시스템들이 서로 다른 목적으로 데이터를 공동으로 이용할 수 있게 한다.

<br>

### DBMS 의 분류

DBMS의 유형은 계층형(Hierarchical), 망형(Network), 관계형(Relational), 객체지향형(Object-Oriented), 객체관계형(Object-Relational) 등으로 분류됩니다. 

**현재 사용되는 DBMS 중에는 `관계형` DBMS** 가 가장 많은 부분을 차지하며, MySQL도 관계형 DBMS에 포함됩니다. 

<br>

### 계층형 DBMS

계층형 DBMS(Hierarchical DBMS)는 처음으로 등장한 DBMS 개념으로 1960년대에 시작되었습니다. 

아래 그림과 같이 각 계층은 `트리tree 형태` 를 갖습니다. 

사장 1명에 이사 3명이 연결되어 있는 구조입니다. 

계층형 DBMS의 문제는 처음 구성을 완료한 후에 이를 변경하기가 상당히 까다롭다는 것입니다. 

또한 다른 구성원을 찾아가는 것이 비효율적입니다. 

예를 들어 재무2팀에서 회계팀으로 연결하려면 재무이사 → 사장 → 회계이사 → 회계팀과 같이 여러 단계를 거쳐야 합니다. 

**지금은 사용하지 않는 형태**

![image](https://github.com/lielocks/WIL/assets/107406265/fbf694ab-484b-47a7-a9fa-0a74c1ef6490)

<br>

### 망형 DBMS

망형 DBMS(Network DBMS)는 계층형 DBMS의 문제점을 개선하기 위해 1970년대에 등장했습니다. 

다음 그림을 보면 하위에 있는 구성원끼리도 연결된 유연한 구조입니다. 

예를 들어 재무2팀에서 바로 회계팀으로 연결이 가능합니다. 

하지만 망형 DBMS를 잘 활용하려면 프로그래머가 모든 구조를 이해해야만 프로그램 작성이 가능하다는 단점이 존재합니다. 

**역시 지금은 사용하지 않는 형태**

![image](https://github.com/lielocks/WIL/assets/107406265/841176cb-8d2c-4d7c-811f-a379a66b6cc4)


<br>

### 관계형 DBMS

관계형 DBMS(Relational DBMS)는 줄여서 RDBMS라고 부릅니다. 

MySQL뿐만 아니라, **대부분의 DBMS가 RDBMS 형태** 로 사용됩니다. 

RDBMS의 데이터베이스는 `테이블(table)` 이라는 최소 단위로 구성되며, 이 테이블은 하나 이상의 열(column)과 행(row)으로 이루어져 있습니다.

한글이나 워드에서 표를 만들었던 경험이 있을텐데요, 이 표의 모양이 바로 테이블입니다. 

친구의 카카오톡 아이디, 이름, 연락처 등 3가지 정보를 표, 즉 테이블로 만들면 다음과 같습니다.

![image](https://github.com/lielocks/WIL/assets/107406265/b764aa84-7698-4835-9cad-15c6527e0a6c)

RDBMS에서는 모든 데이터가 테이블에 저장됩니다. 

이 구조가 가장 기본적이고 중요한 구성이기 때문에 **RDBMS는 테이블로 이루어져 있으며, 테이블은 열과 행으로 구성** 되어 있다는 것을 파악했다면 RDBMS를 어느정도 이해했다고 할 수 있습니다.

<br>

### SQL: DBMS에서 사용하는 언어

SQL(Structured Query Language)은 관계형 데이터베이스에서 사용되는 언어로, ‘에스큐엘’ 또는 ‘시퀄’로 읽습니다. 

SQL이 데이터베이스를 조작하는 ‘언어’이긴 하지만 일반적인 프로그래밍 언어(C, 자바, 파이썬 등)와는 조금 다른 특성을 갖습니다.

SQL은 특정 회사에서 만드는 것이 아니라 국제표준화기구에서 SQL에 대한 표준을 정해서 발표하고 있습니다. 이를 표준 SQL이라고 합니다. 

그런데 문제는 SQL을 사용하는 DBMS를 만드는 회사가 여러 곳이기 때문에 표준 SQL이 각 회사 제품의 특성을 모두 포용하지 못한다는 점입니다. 

그래서 DBMS를 만드는 회사에서는 되도록 표준 SQL을 준수하되, 각 제품의 특성을 반영한 SQL을 사용합니다.

 

다음 그림을 보면 3가지 DBMS 제품(오라클, SQL 서버, MySQL)이 모두 표준 SQL을 포함하고 있습니다. 

**그래서 표준 SQL을 익히면 대부분의 DBMS에 공통적으로 적용** 할 수 있습니다. 

각 DBMS는 추가로 자신만의 기능도 가지고 있어서 이렇게 변경된 SQL을 오라클은 PL/SQL, SQL서버는 T-SQL, MySQL은 SQL로 부릅니다.

![image](https://github.com/lielocks/WIL/assets/107406265/53ce88b9-b518-45f0-a806-be02916c1873)

<br>

## DBMS 는 저장소를 어떻게 관리하는가 ?

### Which Storage Type ? 

저장소를 분류하는 방법에는 다양한 기준이 있겠지만 **`휘발성`** 을 기준으로 나눠보자. 

여기서 휘발성이란 전원을 껐을 때 담겨있던 정보가 사라지는 것을 의미한다.

휘발성이 있는 저장소의 대표격은 역시 RAM이다. 보통 메모리라고 퉁쳐서 부르기도 합니다. 

그리고 비휘발성의 저장소 중 제일 대표적인 것은 HDD일 것입니다. 

일반적으로 데이터베이스를 사용하는 상황은 전원이 켜져있든 꺼져있든 저장된 정보는 유지되어야 합니다. 쇼핑몰의 고객정보가 서버가 꺼지는 순간 다 사라진다면 큰 일이 일어나겠죠.

따라서, 현재의 DBMS는 **`Disk-Oriented`** 입니다. HDD나 SSD, 혹은 네트워크 저장소가 disk를 말합니다.

<br>


### 1. Random Access vs Sequential Access

**`Random Access`** 란 원하는 주소에 바로 접근하는 것을 말합니다.

우리가 조소 10에 위치한 20 바이트의 정보를 사용하고 싶다면 random access 는 바로 주소 10 에 접근해서 20 바이트를 가지고 오는 것을 말합니다.

메모리에선 어떤 주소든 같은 속도로 Random Access 를 지원합니다.

<br>

그럼 Sequential Access는 뭘 말하는 걸까?

저장소에서 어떤 주소를 접근하는 데에 있어어 어떠한 순서가 존재해서 해당 순서로만 접근하는 것을 말합니다.

**Disk 에서는 이러한 Sequential Access 만을 지원합니다.**

<br>

따라서 Random Access 를 하려고 하면 현재 상황에 따라서 그리고 어느 주소에 접근하려냐에 따라서 접근 속도가 크게 달라집니다.

그리고 이는 시간에 있어서 큰 차이를 가져옵니다. 그래서 데이터베이스가 디스크에 파일을 저장할 때는 주소 상에서 연속적으로 저장하는 것이 중요해집니다.

<br>

예시를 들자면 크기가 `1000인 파일이 크기 50씩 20군데로 나뉘어 저장된 것` 은 random access가 20번 발생할 것이고 / `1000이 연속적으로 한 군데에 저장` 되었다면 random access가 한 번 발생한다고 생각하면 됩니다.

<br>

### 2. Byte-Addressable vs Block/Page-Addressable

`메모리에 접근` 할 때는 어떤 주소에 있는 10바이트를 가져와라고 명령하면 정확히 그 주소에 가는 것이 가능합니다. 

이런 식으로 `바이트 단위로 주소 지정이 가능한 것`을 **Byte Addressable** 이라고 합니다.

<br>

반면에 `Disk` 는 어떤 주소로 가라고 했을 때 그 주소가 있는 block 혹은 page 로 가서 해당 주소가 위치한 block 에 접근합니다.

이런 것을 **Block/Page Addressable** 이라고 합니다.

<br>

이 두 특성 때문에 database 파일을 저장하거나 접근할 때, 가능한 연속적으로 또 가능한 한 block 안에 돌어오도록 저장하는 방법을 신경 쓸 필요가 있습니다.

그리고 Disk 접근은 굉장히 비쌉니다. 메모리에 접근하는 시간을 100 초라고 가정했을 때 HDD 에 접근하는 것은 16.5 주에 해당 하는 시간입니다.

<br>

### DISK-ORIENTED DBMS Overview

데이터베이스 파일이 Disk에 존재한다고는 해도 쿼리를 처리하려면 결국 메모리 안으로 들고와야 합니다.

`데이터베이스 파일` 은 머신이 가지고 있는 물리적 메모리보다 클 수도 있습니다. 그래서 DBMS는 *디스크와 메모리 사이* 에서 파일을 어떻게 이동하고 저장할지를 관리합니다. 

+ DBMS 가 메모리 상에서 **`buffer pool`** 이라는 것을 만들고

+ 처리가 필요한 파일 부분을 Disk 에서 가지고 와서 메모리에 올리고

+ 또 필요 없어진 부분은 Disk 로 보내며 메모리를 관리합니다.

**파일을 전부 메모리에 올리진 못하기 때문에 DBMS는 파일을 구성할 때 애초에 여러 조각으로 나누어서 저장을 하는데 그 단위를 보통 **`page`** 라고 부릅니다.**

데이터베이스의 특정 영역에 접근하고 싶다고 **`Buffer Pool Manager`** 에게 명령이 들어오면 **`Buffer Pool Manager`** 는 해당 페이지가 현재 자신이 관리 중인 메모리 상에 존재하는지 체크합니다.

만약에 있다면 해당 내용을 반환하고 없다면 **`page directory`** 라고 page 를 관리하는 자료구조에 접근해서 해당 페이지의 위치를 찾습니다. 
이 때, **`page directory`** 또한 Disk 에 존재하므로 만약에 메모리 상에 존재하지 않는다면 이를 먼저 Disk 에서 들고 옵니다. 그렇게 요구한 page 를 찾은 뒤에 Disk 에서 메모리 상에 올립니다.

위와 같이 파일을 page 로 구성하고 page 단위로 메모리와 Disk 사이에서 파일을 왔다 갔다 하는 이유는 **메모리가 데이터베이스 파일에 비해 매우 작기 때문입니다.** 
전체를 메모리에 담을 수가 없으니 `작은 단위로 필요한 부분을 올려놓고` 필요 없어지면 내려놓고 하는거지요.

![image](https://github.com/lielocks/WIL/assets/107406265/f7d9e86d-645b-4457-a3f4-fba44d32738b)


<br>

위 그림에서 **`Execution Engine`** 이라는 DBMS 의 일부가 **`Buffer Pool Manager`** 에게 2번 페이지를 요구합니다. 이 때 **`page directory`** 가 메모리 상에 없다면 이것부터 Disk 에서 불러오고 그 뒤에 2번 페이지를 directory 에서 찾은 뒤에 들고 옵니다. 그 뒤에 메모리 상의 2번 페이지 주소를 exection engine 에게 돌려줍니다.

위 일련의 과정과 매우 비슷한 일을 하는 프로그램이 하나 더 있습니다. **OS 운영체제** 입니다.

**운영체제** 는 실제 물리 메모리보다 더 큰 메모리를 프로세스에게 제공하기 위해서 프로세스 별로 Page Table 을 관리하며 **`물리메모리와 가상메모리의 page 를 맵핑해주는 역할`** 을 합니다.
또한 물리 메모리가 부족해질 수도 있기 때문에 `Disk 에 swap 공간` 을 따로 두어 **`Buffer Pool Manager`** 와 동일하게 `Disk 에 page 를 내려놓기도 하고 끌어오기` 도 합니다.

심지어 운영체제에 파일과 메모리를 동기화시켜주는 시스템콜(mmap)도 존재하는데 왜 DBMS는 운영체제에게 이러한 메모리 관리를 맡기지 않고 `직접` 할까요?

<br>

## DBMS vs OS

**`DBMS가 직접`** 디스크와 메모리 사이의 페이지 이동을 관리하려는 이유는 간단합니다. 

**OS는 DBMS에서 요구하는 메모리 접근이 어떤 것인지 전혀 알지 못해서 성능을 크게 저하시키기 때문입니다.**

DBMS의 입장에서는 현재 접근 중인 페이지들이 어떻게 쓰일 것인지도 알고 언제 쓸모가 없어질지도 다 아는 상태입니다. 그러나 OS는 모르죠. 
그저 **`프로세스 하나가 read/write를 엄청 많이 할 뿐`** 이에요. 
DBMS라는 프로그램은 태생적으로 `디스크 I/O` 가 많기 때문에 이를 관리하는 것이 매우 큰 이슈입니다. 
그런데 `내가 뭘 하는지도 모르는 OS` 에게 그걸 전부 맡겨버릴 순 없죠. 
`실제 주요 DBMS들, Oracle, Sqlite, SQLServer, Postgresql, 여럿은 직접 page 관리를 합니다.`

<br>

## How DBMS store database files?

데이터베이스 파일은 일단 page 들로 나눠져서 구성된다고 했습니다.
그렇게 저장된다고 생각해도 되겠죠.
그런데 page 들로 쪼갰다고 해도 그것을 어떤 형태로 관리하고 어떤 형태로 저장할지를 정해야 저장소를 관리해주는 프로그램 (Storage Manager) 도 파일들을 읽고 내보내고 할 수 있곘죠.

**`Storage Manager`** 는 Disk 에서 파일을 읽거나 쓰는 것을 효율적으로 관리하기 위한 프로그램입니다. Disk 의 특성상 **Sequential Access** 가 Random Access보다 훨씬 빠르기 때문에 읽기 작업과 쓰기 작업의 지역성을 높이는 형식으로 효율을 높일 수도 있고, dirty page들의 쓰기 순서도 조절해줄 수 있겠지요.

`데이터베이스 파일` 은 위에서도 말했듯이 `페이지들의 모음` 으로 구성됩니다. 
**Collection of Pages** 라고 강의에선 표현합니다. 
**`Storage Manager`** 는 파일을 구성하고 있는 페이지들에 어떤 읽기 연산과 쓰기 연산이 행해졌는지를 관리하며 페이지 내의 남은 공간이 얼마 있는지도 관리하게 됩니다. `이런 정보가 있어야 읽기/쓰기를 쉽게` 할 수 있겠죠.

이제부턴 page 가 어떤 것이고 어떻게 Disk 에 저장되며, page 안에 담기는 정보들은 그 안에 어떤 형식으로 저장되는지에 대한 내용입니다.

<br>

### Pages

파일은 단순히 page 의 모음이라고 했으니 이젠 page 는 어떻게 구성될지 알아보죠. OS 에서 쓰이는 페이지도 그렇듯이 `page = 고정 길이`입니다. 그 길이는 어떤 시스템이냐에 따라 다르게 정의되기도 합니다.

page 는 어떤 정보를 가질 수 있을까요? 

데이터베이스가 가져야 할 내용은 어떤 테이블의 메타 데이터, 실제 레코드들, 인덱스, 로그 등 어떤 정보도 가질 수 있습니다. 그렇다고 두 종류의 정보를 한 페이지 안에 담진 않고 하나의 page 엔 한 종류의 정보만 담는 것이 일반적입니다.

DBMS 중 일부는 전체 page 만 있어도 해당 page 를 이해할 수 있도록 합니다. 
이게 어떤 의미냐면 page 안에 해당 page 내부에 이 page 에 어떤 내용이 담겨 있고 어떻게 해석하면 되는지에 대한 정보가 있어야 한다는 것입니다. 이와 같은 메타데이터가 다른 페이지에 담겨 있다고 할 때, 그런 page 가 손상되었다면 다른 page 를 읽을 수 없기 때문에 위와 같은 제한을 걸기도 합니다.

**각 page 는 유니크한 id를 가져서 이를 지정할 수도 있습니다.** 정리해봅시다.

+ **DBMS Page**
  
  + 고정 길이(Fixed Length)를 가지며 그 길이는 시스템마다 다르게 정의되기도 합니다.

  + 페이지 안에 담길 수 있는 정보는 정말 아무거나 다 가능합니다. 메타데이터, 레코드, 로그, 인덱스 뭐든 상관 없습니다. 다만, 일반적으로 하나의 페이지 안에는 한 종류의 정보만 저장합니다.

  + 각 페이지는 유니크한 **`identifier`** 를 가지고 있어서 어떤 페이지를 찾으면 그 페이지가 어떤 것인지 바로 알 수 있도록 합니다.


DBMS에는 여러 종류의 Page가 등장합니다. 
`Disk 자체의 Page` 가 있고 `OS에서 사용하는 Page`가 있으며, 마지막으로 위에서 언급한 `DBMS가 사용하는 Page` 가 있습니다. 각 page 의 크기는 어떤 시스템이냐에 의존합니다.

**atomic한 연산** 이 중요하게 되는데 **`atomic write를 보장할 수 있는 단위`** 는 **`Disk 의 hardware page의 크기`** 가 됩니다. 만약 DBMS의 페이지는 8KB인데 Disk 의 page 가 4KB라면 8KB의 쓰기 연산 중에서 4KB만 성공하고 4KB는 실패할 수도 있다는 뜻입니다. 이렇듯 DBMS의 page 가 하드웨어의 page 보다 크다면 page 단위의 atomic한 연산을 지원하기 위해서 추가적인 작업이 필요할 것입니다.


<br>

### How to store Pages ?

데이터베이스 파일은 page 로 구성되고 그 page 는 어떤 정보를 담고 있는지 알아봤습니다. 이제 **이 page 들을 Disk 에 어떤 방식으로 저장하고 찾아가는지** 알아봅시다.

DBMS가 page 를 Disk 에 저장하는 여러가지 방법이 있지만 지금 알아볼 것은 **~heap file organization`** 이라는 방식입니다. **`heap file`** 이란 튜플들이 임의의 순서대로 저장되어 있는 페이지들의 **unordered collection** 입니다.

이 heap file을 저장하기 위해서 **`linked list`** 나 **`page directory`** 를 사용합니다.

**`linked list`** 는 굉장히 비효율적인 방식으로 `free page` 와 `data page의 page id들` 을 각각 *리스트 하나* 에 저장하고 필요할 때마다 *해당 리스트를 순차검색* 합니다.

**`page directory`** 란 `각 페이지 id` 와 `그 페이지의 주소` 를 기록해두는 **페이지 테이블** 과 같은 역할을 합니다. `접근하고 싶은 페이지의 id` 를 가지고 있으면 그 페이지가 Disk 의 어디에 위치했는지를 알 수 있어요. 그리고 `해당 페이지에 공간이 얼마나 남았는지` 도 같이 저장해둡니다. 그리고 이러한 정보들을 담은 **`page directory`** 또한 `페이지에 담겨서 Disk 에 저장` 될테니까 이에 대한 정보도 관리를 해줘야 할 것 입니다.

**`page directory`** 안에다 각 페이지의 free space도 기록을 해두기 때문에 `data page에 쓰기 연산을 한 뒤에 **`page directory`** 도 갱신` 을 해야하고 이는 항상 **consistent** 해야 합니다. 이러한 정보의 consistency 관리에도 신경을 써줘야겠죠.

![image](https://github.com/lielocks/WIL/assets/107406265/de1511b0-3e7c-4ef0-a22b-841d10034820)

<br>

### Page Layout

지금까지 본 것은 페이지를 `어떤 방식으로 저장` 해서 `어떤 방식으로 찾아갈지` 에 대한 내용이었습니다. **`linked list`** 나 **`page directory`** 모두 우리가 찾고자 하는 페이지의 id를 알 때 그 페이지가 어디에 저장되어 있는지를 찾는 구조입니다.

이제 **페이지의 내부**는 어떻게 구성되는지 살펴보겠습니다. **페이지는 일단 header 와 data 부분으로 나눠져 있다.** 이 `헤더` 에는 `페이지의 메타데이터` 가 들어있다. 


> 메타 데이터로 쓸모가 있을 정보들은 페이지의 크기, 해당 페이지의 dirty 여부를 체크해줄 
> checksum, 이 페이지 구조를 사용하는 DBMS의 버전, 누가 어떤 트랜잭션이 행해졌는지, 압축되어 있다
> 면 어떤 방식으로 압축되었는지와 같은 것들이다.

![image](https://github.com/lielocks/WIL/assets/107406265/dd03d2fc-2e0c-4762-9c72-cd0883991364)

위에서 언급했던 self-contained page라면 해당 페이지의 정보를 어떻게 해석해야 되는지에 대한 정보 또한 **헤더** 에 같이 담고 있을 것이다.

이제 **data** 부분에 어떻게 저장할지를 알아야 한다. 페이지 안에는 인덱스든 로그든 레코드든 어떤 정보도 저장될 수 있다고 했다. 그러나, 여기서 집중해볼 것은 tuple, 레코드들만 저장한다고 생각하도록 하겠다.

**tuple을 저장하는 방법** 에는 여러가지가 있겠지만 **`tuple-oriented`** 와 **`log-structured`** 의 두 방식을 보자.

<br>

### Tuple Oriented

이 방식은 `페이지 내부에 튜플 자체를 저장`하는 것을 의미한다. 그러면 튜플들을 어떤 방식으로 저장할까?

제일 간단한 것은 **헤더** 에 `현재 저장되어 있는 튜플의 수를 저장` 하고 새로운 튜플을 저장할 때는 그냥 현재 저장되어 있는 튜플의 제일 끝에 넣는 방식이다.

이 방식은 간단해서 좋지만 바로 여러 방면에서 문제가 발생한다. 데이터를 저장하다가 중간에 존재하는 튜플이 삭제되면 그냥 끝에 새로운 튜플을 넣는 방식으론 공간이 낭비된다. 아니면 전부 해당 튜플 이후 전부를 당겨서 저장해서 공간을 절약해야 한다.

이 정도 문제야 뭐 헤더에 현재 비어 있는 공간 위치를 저장해서 해결한다 치자. **만약 튜플이 고정 길이가 아니라 가변 길이라면?** `중간중간에 비어 있는 공간에 들어가는 튜플이 삽입되지 않는다면 그 공간은 계속 낭비` 되고 있을 것이다.

다음 방식은 **Slotted Page** 이다. `튜플을 하나 저장` 할 때마다 `슬롯을 하나 늘리고 튜플을 저장`한다. 그리고 해당 슬롯에는 슬롯에 해당하는 튜플의 시작 주소를 저장한다. **`슬롯들이 저장되는 slot array`** 는 페이지의 시작부분에서 시작하고 데이터는 페이지의 끝에서부터 저장하기 시작한다.

![image](https://github.com/lielocks/WIL/assets/107406265/dc4798a6-9b23-435f-93a8-043645d5c013)

이 방식은 가변 길이여도 문제가 없다. 그러나, 튜플들이 차례로 쌓였을 때 중간의 튜플을 삭제하면 그 공간이 비게 되는 것은 여전한 문제로 남아있다. 그래서 `적절하게 중간 공간들을 압축`해줄 필요는 여전히 있다.

이제 DBMS는 특정 릴레이션의 특정 튜플을 원한다면 그 레코드가 어떤 페이지의 몇 번째 slot에 있는지를 저장해두면 page directory에게 말해서 그 레코드를 가지고 올 수 있게 된다. 이런 정보가 `postgresql에는 CTID라는 내부 값`으로 정의되어 있고 `sqlite과 오라클에서는 ROWID`로 정의되어 있다.

<br>


### Log-structured
튜플 전체를 저장하기보단 튜플이 어떻게 만들어지고 수정되었는지에 관한 기록만 저장해두는 방식이 log-structured 방식이다. 이 방식의 가장 큰 장점은 쓰기 연산을 할 때 빠르다는 점이다. 디스크는 random access 보다 sequential access가 훨씬 빠르다.

튜플의 주소를 찾아서 접근하고 수정하고 삽입하는 것보단 그냥 로그 뭉치를 던져버리면 빠르다. 문제는 읽기다. 로그의 끝 부분부터 필요한 부분까지 전부 읽어야 한다.

읽기 시에 발생하는 오버헤드를 줄이기 위해서 로그의 인덱스를 만들거나 주기적으로 로그를 압축해서 정리해줄 수 있다.

<br>

### Tuple Layout
페이지 안에 튜플을 어떻게 저장할지를 알았다. 그러면 튜플의 내부는 또 어떻게 저장될까? 튜플 또한 메타 데이터를 위한 헤더가 있고 raw data를 저장한다. 중요한 메타데이터로는 특정 속성이 null인지를 나타내는 bitmap이 있다.

관계형 DB에서는 튜플의 스키마를 튜플 헤더에 저장할 필요는 없다고 한다. 왜냐면 튜플마다 다른 스키마를 가지는 것이 아니기 때문이다.

그리고 일반적으로 DBMS가 정의한 스키마의 속성 순서대로 속성을 저장한다.

<br>

## 정리

데이터베이스는 디스크 위에 저장되고 디스크는 느리고 데이터베이스 파일은 정말 크다. 
그래서 메모리에 이를 올리기 위해서는 파일들을 적절히 작은 단위로 나눠서 저장할 필요가 있었고 DBMS에서 파일을 나누는 단위를 페이지라고 부른다.


이제 데이터베이스 파일은 페이지로 나눠져서 디스크 위에 저장된다. 
이 페이지는 시스템마다 크기가 다르지만 고정 길이며 어떠한 정보든 저장될 수 있다. 
DBMS에서는 각 페이지에 unique page id를 부여한다.


데이터베이스 파일은 굉장히 크기 때문에 많은 수의 페이지를 가진다. 그래서 디스크 위에 있는 페이지들을 찾아가기 위해서 추가적으로 관리가 필요하다. 이 방식으로는 heap file 이라는 것을 봤고 이 heap file이라는 것은 일반적으로 page directory라는 방식으로 나타낸다.


page directory는 page id 별로 디스크 상의 주소와 해당 페이지의 남은 공간을 기록해둬서 읽기/쓰기 연산을 할 때 바로 원하는 페이지에 접근할 수 있도록 해줍니다.


파일들은 페이지로 구성되어 있고 페이지들을 찾아가기 위한 방법도 봤으니 페이지 내부를 봅시다.


페이지 내부는 페이지의 크기, dirty여부, 트랜잭션 여부 등의 메타데이터를 저장하는 헤더가 있습니다. 실제 튜플을 저장할 땐 보통 slotted page 방식을 사용합니다.


페이지의 시작 부분에는 slot array가 있고 끝 부분에는 튜플 데이터가 있어서 튜플을 추가하면 튜플은 끝에서부터 차례차례 저장되고 slot array는 시작 부분에서 자라납니다. 그리고 slot array의 slot에는 튜플들의 시작 주소가 저장되어 있습니다.


튜플을 저장하는 다른 방법으로는 log-structured 방식이 있습니다. 이 방식은 튜플 전체를 저장하지 말고 튜플의 변화에 관한 기록만 저장해둡니다. 이렇게 함으로 쓰기 연산이 굉장히 빨라집니다. 문제는 읽기인데 저장된 로그에서 원하는 튜플의 정보를 복원해야 되기 때문입니다.


읽기의 오버헤드를 줄이기 위해서 튜플에 대해서 로그의 인덱스를 만들거나 주기적으로 로그를 압축하기도 합니다.


튜플을 저장하는 방식을 봤으니 튜플 내부를 봐야죠. 튜플 또한 속성들의 null 여부와 같은 메타데이터를 헤더에 갖고 있습니다. 관계형 DB에서는 일반적으로 한 페이지 내부의 튜플들은 같은 스키마를 가지고 있기에 헤더에 메타데이터를 들고 있을 필요는 없습니다. JSON-based DB의 경우는 튜플마다 스키마가 달라질 수 있기 때문에 필요할 수도 있습니다. 그리고 속성들이 저장되는 순서는 보통 스키마를 정의한 순서와 동일합니다.

<br>


## DDL DML DCL 

+ **DDL (Data Definition Language)**

객체의 생성, 변경, 삭제 명령어를 뜻한다.

예를 들어 create, alter, drop, rename 등이 있다.

schema, domain, table, view, index 를 정의, 변경, 삭제할 때 사용하는 언어이다.

주로 데이터베이스 관리자나 데이터베이스 설계자가 사용한다.

데이터 정의어는3가지 유형으로 `create, alter, drop` 이 있다.

+ **DML (Data Manipulation Language)**

레코드 제어 명령여이다. 

예를 들어, select, insert, update, delete 등이 있다.

데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공한다.

데이터베이스 사용자가 응용 프로그램이나 질의어를 통한다.

저장된 데이터를 실질적으로 처리하는데 사용하는 언어이다.

데이터 조작어는 4가지 유형으로 `select, insert, delete, update` 가 있다.

+ **DCL (Data Control Language)**

객체 권한 부여 등의 제어어 이다. 

데이터의 보안, 무결성, 데이터 회복, 병행 수행 제어 등을 정의하는데 사용하는 언어이다.

데이터 베이스 관리자가 데이터 관리를 목적으로 사용한다.

데이터 제어어의 종류로는 `commit, rollback, grant, revoke` 등이 있다.

<br>

## 옵티마이저 (Optimizer)

**옵티마이저는 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DBMS의 핵심 엔진이다.**

컴퓨터의 두뇌가 CPU 인 것 처럼 DBMS 의 두뇌는 옵티마이저라고 할 수 있다.

개발자가 SQL을 작성하고 실행하면 소프트웨어 실행파일처럼 즉시 실행되는 것이 아니라 옵티마이저 (optimizer) 라는 곳에서 `"이쿼리를 어떻게 실행시키겠다!"` 라는 여러 가지 실행계획을 세우게 된다. 

이렇게 실행계획을 세운 뒤 시스템 통계정보를 활용하여 각 실행계획의 예상 비용을 산정한 후 각 실행계획을 비교해서 최고의 효율을 가지고 있는 실행계획을 판별한 후 그 실행계획에 따라 쿼리를 수행하게 되는 것이다. 

![image](https://github.com/lielocks/WIL/assets/107406265/6f137901-38c6-4965-bbc4-7c38cea6a2b0)

<br>

### 옵티마이저의 종류

옵티마이저는 실행 계획을 세우는 방식에 따라 **규칙 기반 옵티마이저** 와 **비용 기반 옵티마이저** 로 나뉩니다.

![image](https://github.com/lielocks/WIL/assets/107406265/6007b17c-fe08-403d-b835-c51098e448de)

<br>

### 규칙 기반 옵티마이저 (RBO)

오라클8 이하의 버전에서 기본으로 설정된 옵티마이저가 바로 규칙 기반 옵티마이저입니다. 

규칙 기반 옵티마이저는 **말 그대로 실행 속도가 빠른 순으로 규칙을 먼저 세워두고 우선순위가 앞서는 방법을 채택** 하는 것입니다. 

과거에는 옵티마이저의 비용을 예측하는 능력이 그다지 좋지 않아 이러한 방식을 사용하였습니다. 규칙의 우선순위는 아래와 같습니다.


![image](https://github.com/lielocks/WIL/assets/107406265/e9077a16-ea29-4845-8a02-26c927d944be)

쿼리문을 효율적으로 작성하는데 큰 도움이 되니 꼭 한번 공부해보시길 바랍니다. 

이렇게 규칙 기반 옵티마이저는 우선순위에 순위가 매겨져 있기 때문에 옵티마이저에서 실행계획이 세워지는 것을 미리 예측할 수 있는 장점이 있고 

조금 응용하면 내가 원하는 대로 실행 계획이 세워지도록 유도할 수도(?) 있는 장점이 있습니다.


하지만 이게 독이 될수도 있는 게 예를 들어 테이블에 데이터가 몇 개 없을 경우 전체 조회를 했을 경우 `FULL TABLE SCAN` 이 더 빠를 수 있는데 `INDEX를 확인하고 타버린다던지` 하는 비효율적인 실행 계획이 도출될 수 있습니다. 

또한 *옵티마이저의 실행계획을 유도할 수 있는 힌트와 HASH JOIN의 경우* 에는 `규칙 기반 이후에 나온 개념들이므로 여기서는 사용하실 수 없다!` 는 단점이 있습니다.

<br>

### 비용 기반 옵티마이저

최근에 많이 사용하고 있는 옵티마이저 방식이며 오라클 10 이후 버전부터는 공식적으로 비용 기반 옵티마이저만 사용을 하는 것으로 알고 있습니다. 

**비용 기반 옵티마이저는 옵티마이저에서 실행 계획을 세운 뒤(최대 2천개까지) 비용이 최소한으로 나온 실행 계획을 수행합니다.** 

비용기반 옵티마이저는 비용을 예측하기 위해서 규칙 기반 옵티마이저가 사용하지 않는 **`테이블, 인덱스, 칼럼 등의 다양한 객체 통계정보`** 와 **`시스템 통계정보`** 를 이용합니다. 

통계정보가 없는 경우 비효율적인 실행계획을 생성할 수 있으므로, 정확한 통계정보를 유지하는 것이 중요합니다.

<br>

### 비용 기반 옵티마이저의 모드

비용 기반 옵티마이저는 여러 가지 모드가 있습니다. 이 모드에 따라 최적의 비용을 구하는 방식이 조금씩 달라집니다.

+ **CHOOSE** : 현재는 잘 사용하지 않지만 SQL 이 실행되는 환경에서 통계 정보를 가져올 수 있으면 비용 기반 옵티마이저로 / 그렇지 않다면 규칙 기반 옵티마이저로 작동시키는 모드입니다.

+ **FIRST_ROWS** : 옵티마이저가 처리 결과 중 첫 건을 출력하는데 걸리는 시간을 최소화할 수 있는 실행 계획을 세우는 모드입니다.

+ **First_ROWS_n** : SQL 의 실행 결과를 출력하는데까지 걸리는 응답속도를 최적화하는 모드입니다.

+ **ALL_ROWS** : SQL 실행 결과 전체를 빠르게 처리하는데 최적화된 실행 계획을 세우는 모드입니다.

마지막으로 출력될 행까지 최소한의 자원을 사용하여 최대한 빨리 가져오게 하며 오라클 10g 이후로는 이 모드가 기본값으로 설정되어 있습니다.


<br>

### 옵티마이저의 동작 방식

![image](https://github.com/lielocks/WIL/assets/107406265/ee7abbe6-a54e-45a8-9788-05dae25b02f4)

+ **Parser** : SQL 문장을 분석하여 문법 검사와 구성요소를 파악하고 이를 파싱해서 파싱 트리를 만듭니다.

+ **Query Transformer** : 파싱된 SQL을 보고 같은 결과를 도출하되, 좀 더 나은 실행 계획을 갖는 SQL로 변환이 가능한지를 판단하여 변환 작업을 수행한다.

+ **Estimator** : 시스템 통계 정보를 딕셔너리로부터 수집하여 SQL을 실행할 때 소요되는 총비용을 계산한다.

+ **Plan Generator** : Estimator 를 통해 계산된 값들을 토대로 후보군이 되는 실행계획을 도출한다.

+ **Row-Source Generator** : 옵티마이저가 생성한 실행계획을 SQL 엔진이 실제 실행할 수 있는 코드나 프로시저 형태로 포맷팅 합니다.

+ **SQL Engine** : SQL 을 실행합니다.

<br>

## 옵티마이저를 최적으로 활용하기 위해 다루어야 할 내용들

### 통계 정보

앞서 잠깐 설명했지만 비용 기반 옵티마이저에서는 실행 계획 도출 시 DBMS에서 제공하는 통계 정보를 사용합니다. 

이러한 통계정보는 꾸준히 갱신되고 있는 것이 좋습니다. 

통계 정보의 생성 주기 및 수행 시간을 스케줄러에 일괄적으로 등록하여 일정 주기마다 통계 정보를 수집하고 종료하도록 자동 통계 정보를 생성할 수도 있고 

사용자가 직접 수동으로 통계 정보를 생성할수도 있습니다. 

DBMS_STATS 패키지를 사용하면 `데이터베이스, 스키마 및 계정, 테이블 인덱스 단위로 구분` 하여 통계 정보를 수집할 수 있습니다.

<br>

### 주요 통계 정보들

![image](https://github.com/lielocks/WIL/assets/107406265/f2909b90-599c-4891-a510-3597a49ca8ff)


<br>

### 옵티마이저에 영향을 줄 수 있는 파라미터

옵티마이저가 최적의 실행 계획을 결정할 때 파라미터의 값도 매우 중요한 영향을 미친다.

예를 들어 OPTIMIZER_MODE 는 옵티마이저의 모드를 결정하는 파라미터인데 중간에 옵티마이저 모드가 변경된다면 실행계획이 꼬일 수 있겠죠 ?

이와 같이 옵티마이저에 직접적으로 영향을 줄 수 있는 파라미터들은 개발하고자 하는 방향으로 설계 단계에서 최적화로 설정하고 바꾸지 않는 것이 좋다.

<br>

### 옵티마이저는 결코 만능이 아니다.

옵티마이저의 성능은 점차 향상되고는 있지만 결코 만능 X

`칼럼의 통계 정보만 가지고는` 조건절에서 사용된 조건을 만족하는 데이터의 양이 어느정도인지 알 수가 없기에 비용 계산 결과가 정확하지 X

그리고 비용 산정시 쿼리문 단독으로 실행된다고 가정하기에 운영 서버와 같이 쿼리가 동시 실행된다면 실제 비용은 달라질 수 있기도 하고 `히스토그램 버킷이 최대 254 까지만 사용할 수 있어 254 개 이상의 값을 갖는 컬럼` 의 경우 비용 예측 결과가 정확하지 않는 등의 옵티마이저에 여러가지 빈틈들이 많다.

*절대 옵티마이저를 맹신하시면 안 됩니다.*

쿼리 튜닝을 할 때에는 쿼리 문의 실행계획을 꼭 보시고 옵티마이저가 비효율적으로 작동하고 있다면 오라클의 힌트 같은 부가적인 장치를 통해 올바르게 작동될 수 있도록 유도하는 방법도 필요합니다. 

예를 들어 SQL의 바인드 변수의 경우 바인드 변수에 입력될 값의 예측이 가능하다면 입력받을 값에 따라 적절한 힌트를 사용할 수 있겠습니다.

