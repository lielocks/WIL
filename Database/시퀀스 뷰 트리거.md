## 뷰(view)

**뷰(view)** : 물리적인 테이블에 근거한 논리적인 가상 테이블
  
가상이란 단어는 실질적으로 데이터를 저장하고 있지 않기 때문에 붙인 것이고, 그럼에도 테이블이란 단어는 실질적으로 데이터를 저장하고 있지 않더라도
사용 계정자는 마치 테이블을 사용하는 것과 동일하게 뷰를 사용할 수 있기 때문에 붙여진 것입니다.

뷰는 결국 기본테이블에서 파생된 객체로서 *기본 테이블에 대한 하나의 함수* 처럼 생각해도 좋겠네요.

실제 테이블에 저장된 데이터를 뷰를 통해서 볼 수 있도록 합니다.

사용자에게 주어진 뷰를 통해서 기본 테이블을 제한적으로 사용할 수 있습니다.

뷰는 이미 존재하고 있는 테이블에 제한적으로 접근하도록 합니다.

+ 뷰를 생성하기 위해서는 `실질적으로 데이터를 저장하고 있는 물리적인 테이블` 이 존재해야 되는데 이 테이블은 기본 테이블이라고 합니다

+ 두개 이상의 테이블 또는 한 개의 테이블이나 또 다른 뷰를 참조하는 객체입니다

+ 저장된 테이블이라기 보다 공식 또는 select 문을 갖고 있다가 명령대로 불러와 그때그때 구성하는 형식입니다

+ 원본의 데이터 변화는 실시간으로 반영됩니다
 

![image](https://github.com/lielocks/WIL/assets/107406265/e4304755-9e2e-407e-9160-a79c5448606d)


<br>


## 시퀀스 (sequence)

**시퀀스(sequence)** : 유일한 값을 생성해주는 오라클 객체, 자동증가(넘버링)

  이는 시퀀스를 생성하여 마치 `기본키(primary key)` 와 같이 순차적으로 증가하는 칼럼을 자동으로 생성해줍니다.

- 시퀀스는 이런 성질 때문에 대량의 데이터를 다룰 때 기본키의 값을 생성하기 위해 사용하고

  시퀀스는 테이블과는 독립적으로 저장되고 만들어지기 때문에 하나의 시퀀스를 생성하여 여러 테이블에 적용하여 활용하면 좋습니다

```sql
생성 방법
-- create sequence 시쿼스 이름 start with 시작 숫자 increment by 증가량;
 
--[1] 샘플 테이블 생성
create table memos(
 num  number(4) constraint memos_num_pk primary key,
 name  varchar2(20) constraint memos_name_nn not null,
 postDate  Date default(sysdate)
);
 
--[2] 해당 테이블의 시퀀스 생성
create sequence memos_seq start with 1 increment by 1;
-- memos_seq : 시퀀스의 이름
-- start with 1 : 시작 숫자
-- increment by 1 : 증감량
 
--[3] 데이터 입력 : 일련번호 포함
insert into memos(num, name) values(memos_seq.nextVal , '홍길동');
insert into memos(num, name) values(memos_seq.nextVal , '이순신');
insert into memos(num, name) values(memos_seq.nextVal , '강감찬');
insert into memos(num, name) values(memos_seq.nextVal , '유관순');
insert into memos(num, name) values(memos_seq.nextVal , '장영실');
 
select * from memos;
 
--[4] 현재 시퀀스가 어디까지 증가되어져 있는지 확인.
select memos_seq.nextVal, memos_seq.currval from dual;
 
--[5] 시퀀스 수정 : 최대 증가값을 14까지로 제한.
alter sequence memos_seq  maxvalue  14;
insert into memos(num, name) values(memos_seq.nextVal, '안중근');
insert into memos(num, name) values(memos_seq.nextVal, '김구');
insert into memos(num, name) values(memos_seq.nextVal, '세종대왕');
insert into memos(num, name) values(memos_seq.nextVal, '안중근');
insert into memos(num, name) values(memos_seq.nextVal, '김구');
select * from memos;
 
--[6] 시퀀스 삭제
drop sequence memos_seq;
--[7] 시퀀스 재생성 : 14 다음 숫자부터 시작하게 하여 기존 레코드와 중복 되지 않게 합니다
create sequence memos_seq start with 15 increment by 1;
```

<br>


**뷰** : 실제 데이터는 건들지 않고 원하는 내용만 가져다 모아서 확인할 수 있는 가상의 테이블. 뷰는 실제 테이블에 제한적으로 접근하도록 하여 보안에도 유리함.

**시퀀스** : 기본키를 효과적으로 사용하기 위한 일련번호 자동 생성기이다

<br>


## 트리거(Trigger) 란?

트리거(Trigger)란 영어로 방아쇠라는 뜻인데, 방아쇠를 당기면 그로 인해 총기 내부에서 알아서 일련의 작업을 실행하고 총알이 날아갑니다. 

이처럼 데이터베이스에서도 *트리거(Trigger)는 특정 테이블에 INSERT, DELETE, UPDATE 같은 DML 문이 수행* 되었을 때, **데이터베이스에서 자동으로 동작** 하도록 작성된 프로그램입니다. 

즉 사용자가 직접 호출하는 것이 아니라, 데이터베이스에서 자동적으로 호출하는 것이 가장 큰 특징입니다. 

트리거(Trigger)는 *테이블* 과 *view 데이터베이스 작업* 을 대상으로 정의할 수 있으며, 
*전체 트랜잭션 작업* 에 대해 발생되는 트리거(Trigger)와 *각행에 대해 발생* 되는 트리거(Trigger)가 있습니다.

<br>


### 트리거(Trigger)가 적용되는 예

다음과 같은 상황에서 트리거(Trigger)를 사용할 수 있습니다. 

어떤 쇼핑몰에 하루에 수만 건의 주문이 들어옵니다. 

주문데이터는 `주문일자, 주문상품, 수량, 가격` 이 있으며, 수천명의 임직원이 `일자별, 상품별 총 판매수량과 총 판매가격으로 구성된 주문 실적` 을 실시간으로 온라인상에 조회를 했을 때, 

한사람의 임직원이 조회할 때마다 *수만 건의 데이터를 읽고 계산* 해야합니다. 

만약 임직원이 수만명이고, 데이터가 수백만건이라면, 또 거의 동시다발적으로 실시간 조회가 요청된다면 시스템 퍼포먼스가 떨어질 것입니다.

따라서! **트리거(Trigger)** 를 사용하여 `주문한 건이 입력될 때마다`, 일자별 상품별로 판매수량과 판매금액을 집계하여 집계자료를 보관하도록 만들어보겠습니다. 

먼저 관련된 테이블을 생성해보겠습니다.

<br>


![image](https://github.com/lielocks/WIL/assets/107406265/52742548-9b2c-436b-85a0-4d8ddad920ed)

<br>


테이블은 다음과 같습니다. 

`주문정보테이블` 에 실시간으로 데이터가 입력될 때마다 trigger 가 발동되어 자동으로 `일자별판매집계테이블` 에 일자별, *상품별 판매수량과 판매금액* 을 계산해 업데이트 하는 작업을 하도록 하고, 

사용자들은 **미리 계산된** `일자별판매집계테이블` 을 조회하게 하여 *실시간 조회* 를 지원하게 하는 것입니다.

<br>


### 트리거(Trigger) 구현

자, 이제 2개 테이블을 CREATE, DDL을 통해 만들어보겠습니다.

```sql
CREATE TABLE ORDER_LIST(

    ORDER_DATE  CHAR(8) NOT NULL,
    PRODUCT     VARCHAR2(10) NOT NULL,
    QTY         NUMBER NOT NULL,
    AMOUNT      NUMBER NOT NULL
);
```

```sql
CREATE TABLE SALES_PER_DATE(
    SALE_DATE   CHAR(8) NOT NULL,
    PRODUCT     VARCHAR2(10) NOT NULL,
    QTY         NUMBER NOT NULL,
    AMOUNT      NUMBER NOT NULL
);
```

```sql
SELECT *
FROM ORDER_LIST

SELECT *
FROM SALES_PER_DATE
```

조회를 해보면 다음과 같습니다.

![image](https://github.com/lielocks/WIL/assets/107406265/602ee887-4153-49b6-af6a-d7a3e16340cf)

![image](https://github.com/lielocks/WIL/assets/107406265/62206a2d-9e04-4c6c-aaa9-c00fc59249d4)

아직 2개 테이블 다 데이터가 없음을 확인할 수 있습니다. 

이제 트리거(Trigger)를 만들어 보겠습니다. 

트리거(Trigger)를 구현하기 위해 우선 `절차형 SQL` 과 `PL/SQL` 을 알아야합니다. 

절차형 SQL과 PL/SQL을 안다는 전제하에 트리거(Trigger)를 구현해보겠습니다.

<br>


![image](https://github.com/lielocks/WIL/assets/107406265/db6576a7-e1e5-407a-89e1-0d9d71033020)

<br>

**8 ~ 14 Line** 

**`Trigger`** 를 선언합니다. 

order_list 테이블에 insert 가 발생하면 그 이후 each row 즉 `각 행에 해당 트리거(Trigger)를 적용` 한다라는 뜻입니다. 

또한, *declare 선언문에는 변수를 선언* 합니다. 

order_list 테이블에 있는 order_date, product Type에 맞게 `o_date, o_prod 변수` 를 선언합니다.

<br>

**15 ~17 Line**

`new` 는 **트리거(Trigger)에서 사용하는 구조체** 입니다. new 는 *새로 입력된 레코드 값* 을 담고 있습니다.

o_date 에 `새로 들어온 order_date 값` 을 , o_prod 에 `새로 들어온 product 값` 을 저장합니다.

<br>

**18 ~ 26 Line**

`sales_per_date 테이블` 에 update 구문을 실행하는데, `기존에 있는 qty, amount 를 누적합` 해서 다시 **Set** 합니다. 

여기서 `where문` 을 통해 *현재 새로 들어온 날짜과 상품이 일치하는 데이터만* 해당 update문을 실행하도록 조건을 걸었습니다. 

또한 만약 해당 조건에 *모두 해당되지 않는다면, if sql%notfound* 구문이 실행됩니다. 

기존에 있던 레코드 값이 아니고 전혀 새로운 레코드이기 때문에 insert 구문을 통해 새로 들어온 데이터를 새로 삽입합니다. 

끝으로 `/ 부분` 은 **트리거(Trigger)를 실행하는 실행명령어** 입니다.

<br>

위 구문을 실행하면, 이제 *2개 테이블에 트리거(Trigger)* 가 적용된 것입니다. 

<br>


이제 `order_list 테이블` 에 레코드를 insert 해서 `sales_per_date 테이블` 에 트리거(Trigger)가 자동으로 동작하여, 데이터 값을 자동으로 계산하고 반영하는지 확인해보겠습니다!

ORDER_LIST 테이블에 아래와 같이 데이터 값을 삽입해보겠습니다.

**-> INSERT INTO ORDER_LIST VALUES('20120901','MONOPACK',10,300000)**

삽입후 ORDER_LIST, SALES_PER_DATE 테이블 조회를 해보겠습니다.

ORDER_LIST 정상적으로 값이 삽입되었습니다.

<br>


![image](https://github.com/lielocks/WIL/assets/107406265/75c38cdc-b37c-4abf-94a6-32e9aa6f5d1a)

**트리거** 에 의해서 SALES_PER_DATE 에도 정상적으로 값이 삽입되어있습니다.

![image](https://github.com/lielocks/WIL/assets/107406265/a673689a-8e68-482b-80a4-cb4c3dbfce4c)

자. 다시한번 값을 삽입하고 테이블을 확인해보겠습니다.

**-> INSERT INTO ORDER_LIST VALUES('20120901','MONOPACK',20,600000);**

ORDER_LIST 를 조회하면 지금까지 삽입한 값들이 리스트로 있습니다.

![image](https://github.com/lielocks/WIL/assets/107406265/654e4c1e-2ded-4abd-a939-0723196bacbb)

`SALES_PER_DATE 테이블` 은 **트리거** 에 의해서 *주문날짜별 상품별 물량과 가격이 합산* 되어 업데이트 되어있음을 확인할 수 있습니다.

![image](https://github.com/lielocks/WIL/assets/107406265/f3bf56d9-310f-47a8-aca2-e523123ccfc0)

<br>


## 트리거(Trigger)와 트랜잭션(Transaction)의 상관관계

이번에는 다른 상품으로 주문 데이터를 입력한 후 두 테이블의 결과를 조회해보고 `트랜잭션을 ROLLBACK` 해보겠습니다. 

판매 데이터의 **입력취소** 가 일어나면, `주문 정보 테이블(ORDER_LIST)` 과 `판매 집계테이블(SALES_PER_DATE )` 에 *동시에 입력(수정) 취소가 일어나는지* 확인해보기 위함입니다.

**-> INSERT INTO ORDER_LIST VALUES('20120901','MULTIPACK',10,300000);**

ORDER_LIST 에 정상적으로 판매 데이터가 삽입되었습니다. 

![image](https://github.com/lielocks/WIL/assets/107406265/1c3b66fc-9e57-4731-81cc-03e56bb62bbf)

SALES_PER_DATE 테이블은 **트리거** 에 의해 판매날짜별, 상품별 누적 물량과 가격이 업데이트 되었습니다.

![image](https://github.com/lielocks/WIL/assets/107406265/ff56fd5e-9a50-4fdd-a15f-bede52154fea)

이제 **`ROLLBACK;`** 명령어를 실행해보겠습니다. 

`ORDER_LIST 테이블` 에 *방금 삽입한 판매데이터가 취소* 되었습니다.

![image](https://github.com/lielocks/WIL/assets/107406265/cb61d0b1-3fc6-4573-a9eb-fa887b2c497e)

`SALES_PER_DATE 테이블` 에도 똑같이 **트리거** 로 입력된 데이터 정보까지 ***하나의 트랜잭션으로 인식하여 입력 취소가 되었습니다.***

![image](https://github.com/lielocks/WIL/assets/107406265/39ac86a0-8d42-4df3-a671-c17acb66a6bb)

<br>

즉, **트리거**는 데이터베이스에 의해 `자동 호출`되지만 

**결국 `INSERT, UPDATE, DELETE 구문과 하나의 트랜잭션 안에서` 일어나는 일련의 작업들이라 할 수 있습니다.** 

(추가로 트리거는 Begin ~ End 절에서 COMMIT , ROLLBACK 을 사용할 수 없습니다.)

