## 인덱스(Index) 란?

**인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조입니다.**

특정 컬럼에 인덱스를 생성하면, *해당 컬럼의 데이터들을 정렬* 하여 **`별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장`** 된다.

이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로 거는 등" 의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수가 있습니다.

만약 인덱스를 타게 되면 아래의 그림과 같이 인덱스를 타게 되고 먼저 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 도작을 하여 검색 성능 속도 향상 !

![image](https://github.com/lielocks/WIL/assets/107406265/02215dbb-1a93-44a2-8c93-5a2820fbf9cc)

즉 인덱스는 책에 있는 목차라고 생각하시면 편합니다. 

우리가 책에서 정보를 찾을때도 먼저 원하는 카테고리를 목차에서 찾고 목차에 있는 페이지 번호를 보고 찾아가듯 인덱스도 인덱스에서 내가 원하는 데이터를 먼저 찾고 저장되어 있는 물리적 주소로 찾아갑니다. 

이 Index에 관한 내용은 자세히 알아두는 것이 좋습니다. 

실제 DB 관련 작업을 할 때 대부분의 속도 저하는 바로 Select문 특히 조건 검색 Where절에서 발생하는데 가장 먼저 생각해 볼 수 있는 대안으로 Index를 생각할 수 있기도 하고, 

SQL 튜닝에서도 Index와 관련된 문제사항과 해결책이 많기 때문입니다.

<br>

### 인덱스를 사용하는 이유

테이블에 데이터들이 인덱스의 가장 큰 특징은 데이터들이 정렬이 되어있다는 점입니다.

이 특징으로 인해 조건 검색이라는 영역에서 굉장한 장점이 된다.

<br>

### 조건 검색 Where 절의 효율성

테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장된다.

이렇게 되면 Where 절에 특정 조건에 맞는 데이터들을 찾아낼때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과 맞는지 비교해야 합니다. 

이것을 풀 테이블 스캔 (Full Table Scan)이라고 합니다. 

하지만 **`인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에`** 해당 조건 (Where)에 맞는 데이터들을 빠르게 찾아낼 수 있겠죠. 

이것이 인덱스(Index)를 사용하는 가장 큰 이유입니다. 

<br>

### 정렬 Order by 절의 효율성

**인덱스를 사용하면 Order by 에 의한 Sort 과정을 피할 수가 있습니다.**

Order by -> 굉장히 부하가 많이 걸리는 작업 !

`정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고` 메모리보다 큰 작업이 필요하다면 `디스크 I/O` 도 추가적으로 발생됩니다.

하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 됩니다.

**이미 정렬이 되어 있기 때문에 가져오기만 하면 되니까요**

<br>

### MIN MAX 의 효율적인 처리가 가능하다

이것 또한 **데이터가 정렬되어 있기에 얻을 수 있는 장점** 입니다.

MIN 값과 MAX 값을 레코드의 시작값과 끝 값 한건씩만 가져오면 되기 때문에 FULL TABLE SCAN 으로 테이블을 다 뒤져서 작업하는 것보다 훨씩 효율적입니다.

<br>

### 인덱스의 단점

인덱스가 주는 혜택이 있으면 그에 따른 부작용도 있습니다.

**인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지 시켜줘야 한다는 점입니다.**

그렇기에 레코드 내에 데이터 값이 바뀌는 부분이라면 악영향을 미칩니다.

INSERT, UPDATE, DELETE 를 통해 데이터가 추가되거나 값이 바뀐다면 INDEX 테이블 내에 있는 값들을 다시 정렬을 해야겠죠.

그리고 INDEX 테이블, 원본 테이블 이렇게 두군데에 데이터 수정 작업해줘야 한다는 단점도 있습니다

<br>


**그리고 검색시에도 인덱스가 무조건 좋은 것은 아닙니다**

인덱스는 테이블의 전체 데이터 중에서 `10~15% 이하의 데이터` 를 처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫습니다.

그리고 인덱스를 관리하기 위해서는 **`데이터베이스의 약 10% 에 해당하는 저장공간이 추가로 필요`** 합니다.

무턱대고 INDEX 를 생성하지 말자 !

<br>

### Index 가 수정 삭제가 많이 일어나는 테이블에 맞지 않는 이유

인덱스는 또 다른 기존 테이블외에 인덱스 테이블을 가지고 있기 때문에 사용하면 검색속도가 빨라진다. 

하지만 DML (INSERT, UPDATE, DELETE) 이 자주 일어나는 테이블의 경우 오히려 성능이 떨어진다.

기본적으로 인덱스는 데이터를 삭제하더라도 `사용안함` 표시를 해주고 끝이지 실제로 사라지는 것이 X

또한 `UPDATE 문을 사용해서 데이터를 수정하는 경우` 에도 우리 눈에는 그냥 수정만 된것이지만 내부적으로는 **`DELETE 후에 다시 INSERT 해주는 로직을 따르고 있다.`**

그렇기 때문에 DML 이 자주 일어나는 table 에서는 오히려 INDEX TABLE 이 원래 TABLE 보다 커지는 경우가 발생하게 되고,

그렇게 되면 INDEX를 사용하는 의미가 사라진다.

<br>

### 인덱스의 관리

앞서 설명했듯이 인덱스는 `항상 최신의 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색` 할 수 있습니다. 

그렇기 때문에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 `계속 정렬` 을 해주어야 하고 그에 따른 부하가 발생합니다. 

이런 부하를 최소화하기 위해 인덱스는 **데이터 삭제** 라는 개념에서 **인덱스를 사용하지 않는다** 라는 작업으로 이를 대신합니다.

<br>

### 인덱스 생성 전략

생성된 인덱스를 가장 효율적으로 사용하려면 **`데이터의 분포도는 최대한`** 으로 그리고 **`조건절에 호출 빈도는 자주 사용되는 컬럼`** 을 인덱스로 생성하는 것이 좋습니다. 

인덱스는 특정 컬럼을 기준으로 생성하고 **기준이 된 컬럼으로 정렬된 Index 테이블이 생성** 됩니다. 

이 기준 컬럼은 **최대한 중복이 되지 않는 값** 이 좋습니다. 가장 최선은 `PK` 로 인덱스를 거는것이겠죠. 

중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고, 반대로 모든 값이 같은 컬럼이 인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것입니다.


1. 조건절에 자주 등장하는 컬럼

2. 항상 = 으로 비교되는 컬럼

3. 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은) 컬럼

4. ORDER BY 절에서 자주 사용되는 컬럼

5. JOIN 조건으로 자주 사용되는 컬럼

<br>

### 인덱스 자료구조

**B-Tree 구조**

`B Tree` 는 이진트리에서 발전되어 모든 리프 노드들이 같은 레벨을 가질 수 있도록 자동으로 밸런스를 맞추는 트리이다.

`정렬된 순서`를 보장한다.

내부적으로 여러 방식을 구현하지만 제일 보편적인 것이 B-Tree 인덱스이다.

Storage Engine 에 따라 인덱스 구조가 다른데 MYSQL 의 경우에 가장 많이 사용하는 Storage Engine 은 InnoDB, MYISAM 같은 경우에는 B-Tree 로 되어 있고

Memory / Heap , NDB 등은 HASH 와 B-Tree로 되어 있다.

![Untitled](https://github.com/lielocks/WIL/assets/107406265/5b976d4e-854b-4ac3-8d34-372d80e1e7e7)

**B-Tree 동작방식**

1. Branch Block 의 가장 왼쪽 값이 찾고자 하는 값보다 작거나 같으면 왼쪽 포인터로 이동

2. 찾고자 하는 값이 Branch Block 의 값 사이에 존재하면 가운데 포인터로 이동

3. 오른쪽에 있는 값보다 크면 오른쪽 포인터로 이동

<br>


![Untitled (1)](https://github.com/lielocks/WIL/assets/107406265/f5cfff3d-ba63-474c-83d3-af14946c9095)

+ 예를 들어 37의 값을 찾고 싶다면 ?
  + 37을 찾고자 한다면 Root Block 에서 50보다 작으므로 왼쪽 포인터로 이동한다.
  + 37은 왼쪽 Branch Block 의 11과 40 사이의 값이므로 가운데 포인터로 이동한다.
  + 이동한 결과 해당 블록이 Leaf Block 이므로 37 이 Block 내에서 존재하는지 검색한다.

+ 또 예를 들어 37~50 사이의 값을 찾고 싶다면?
  + 앞에서와 같이 37 을 찾은 다음에 정렬되어 있는 link를 따라 50 까지 검색해주면 된다.
 
<br>

## 클러스터형 인덱스와 비클러스터형 인덱스

### 데이터베이스에서 클러스터 Cluster 란?

보통 데이터베이스 구축의 경우 1개의 서버로 하나의 데이터베이스를 구축해서 사용하는 편입니다.

그런데 이렇게 1개의 서버가 하나의 데이터베이스를 사용할 경우 이 서버가 죽으면 서비스가 죽는 현상이 발생하게 됩니다.

또는 사용자가 엄청나게 유입되었을 때 이에 대한 처리를 서버 하나가 처리할려고 하면 서버는 견디지 못하고 뻗어버리게 됩니다.

이런 여러가지 이유로 **하나의 데이터베이스를 여러 서버가 나눠서 구축** 하게 됩니다.

이처럼 **하나의 데이터베이스를 여러개의 서버로 구축되는 경우를 클러스터(Cluster)** 라고 지칭합니다.

<br>

데이터베이스 클러스터의 조건을 만족시키기 위해선 아래 3가지의 요구를 모두 할 수 있어야 합니다.

<br>

**1. 고가용성**

데이터베이스에서 가용성이란 데이터베이스가 동작하는 시간과 정지한 시간의 비율을 뜻한다.

즉, **1년 동안 몇 분이 정지했음을 비율로 나타낸 것이 가용성** 인데요.

데이터베이스도 컴퓨터 위에서 돌아가기 때문에 여러분도 알다시피 컴퓨터는 여러 이유로 멈출때가 있습니다(어떨 땐 아무 이유 없이 꺼질 때도 있는거 같아요).

이런 현상이 일어났을 때 서버가 하나뿐이라면 서비스는 데이터베이스가 복구될 때까지 정지되는 크나큰 장애가 발생하게 됩니다.

이처럼 **한 부분의 문제가 전체 시스템을 정지시켜 버리는 것을 SPOF(Single Point Of Failure)** 라고 합니다. 이를 해결하기 위해 고가용성 클러스터를 사용합니다.

![image](https://github.com/lielocks/WIL/assets/107406265/45027d0f-134d-43ac-9208-e6478f53a979)

<br>

**2. 병렬처리**

테이블에 데이터도 엄청 많고 컬럼(필드)도 엄청 많아 SQL 문이 복잡하게 될 경우 SQL 문을 실행하는데 많은 시간이 걸리게 됩니다.

이런 상황에서 데이터베이스를 여러개의 단위별로 **`병렬처리해서 결과를 통합하여 넘겨준다면`** 훨씬 빠르게 결과를 얻을 수 있습니다.

복제 데이터베이스는 항상 원본 데이터베이스와 같은 데이터를 가지고 있기 때문에 DML(SELECT, INSERT, UPDATE, DELETE)을 고려해서 분산시키면 전체적인 성능향상을 시킬 수 있습니다.

데이터베이스 클러스터는 병렬처리를 할 수 있어야 합니다.

<br>

**3. 성능 향상**

데이터베이스를 사용하는 사용자가 엄청나게 많아질 경우 데이터베이스의 복제본을 만들어서 참조 처리의 경우 복제 데이터베이스를 사용하면 사용자가 많아져도 대비를 할 수 있습니다.

데이터베이스 클러스터는 이러한 성능향상을 만족시킬 수 있어야 합니다.

<br>

### 결론

+ 데이터베이스에서 클러스터란 여러개의 서버가 하나의 데이터베이스를 나눠서 처리하는 형태를 뜻한다.

+ 고가용성, 병렬처리, 성능향상 이러한 3가지를 만족하는 시스템의 구성형태를 데이터베이스 클러스터라고 한다.

<br>

### 인덱스가 없을 경우

![image](https://github.com/lielocks/WIL/assets/107406265/b24f0136-03e6-47f9-887b-dced4761f619)


위와 같이 1위부터 10위까지의 인기있는 프로그래밍 언어가 들어있는 테이블이 있다고 가정하자. 

첫번째 열은 순위를 나타내는 **`rank`** 열, 두번째 열은 언어의 이름을 나타내는 **`language`** 열이다.

위 그림은 인덱스가 없는 테이블의 페이지 구성이다. 그냥 **데이터가 삽입된 순서대로 들어있는 모습** 을 볼 수 있다. 

편의상 페이지의 크기를 4개로 표현했지만 당연히, 실제 데이터베이스의 페이지 크기는 이렇게 작지 않다.

<br>

### 클러스터형 인덱스 Clustered Index

클러스터형 인덱스는 **테이블 전체가 정렬된 인덱스가 되는 방식** 의 인덱스 종류이다.

**실제 데이터와 무리 (cluster) 를 지어 인덱싱** 되므로 클러스터형 인덱스라고 부른다.

데이터와 함께 **전체 테이블이 물리적으로 정렬** 된다.

클러스터형 인덱스는 영어 사전과 비슷하다.

영어 사전은 영어 단어가 사전순으로 정렬되어 있으면서, 영어 단어의 뜻도 함께 존재하기 때문이다.

<br>

클러스터형 인덱스는 **테이블당 하나** 만 생성할 수 있다.

어떤 column 을 선택해 클러스터형 인덱스를 만들지에 따라 성능이 좌우될 수 있다.

특정 column 을 **PK로 지정하면 클러스터형 인덱스를 생성** 한다.

혹은 **Unique + Not null 로 지정해도 클러스터형 인덱스를 생성**한다.

PK 컬럼과 Unique + Not null 컬럼이 동시에 존재하는 테이블은 **PK를 우선** 으로 선택해 클러스터형 인덱스를 생성한다.

이 두가지가 모두 없는 경우 InnoDB 는 내부적으로 **`GEN_CLUST_INDEX`** 라는 컬럼을 생성하여 클러스터형 인덱스를 생성한다.

**`GEN_CLUST_INDEX`** 는 행이 생선된 순서대로 값이 부여된다.

![image](https://github.com/lielocks/WIL/assets/107406265/7f5547b3-3e84-4194-ab0c-dbd9d924fdb4)

클러스터형 인덱스는 위 그림처럼 **B+Tree** 의 형태로 구성되어 있다.

앞으로 여기서 B+Tree 의 노드를 데이터베이스에서는 **페이지**라고 부른다.

각 페이지는 고유의 **페이지 번호**를 가지고 있다.

위 그림은 `rank` 컬럼을 PK 로 설정해 클러스터형 인덱스를 생성한 모습이다.

<br>

루트 페이지를 보면 **Key 로는 PK** 를 가지고 있고, 포인터로는 **다른 페이지의 페이지 번호** 를 가지고 있다.

또, 리프 페이지는 Key 로는 PK 를 가지고 있고, **데이터를 직접 가지고 있는 것** 을 확인할 수 있다.

<br>

### 비클러스터형 인덱스 Non-Clustered Index

비클러스터형 인덱스는 보조 인덱스 Secondary Index 라고도 불리며, 
클러스터형 인덱스와 다르게 **물리적으로 테이블을 정렬하지 않는다.**

그 대신 **정렬된 별도의 인덱스 페이지를 생성하고 관리**한다.

즉, **실제 데이터를 함께 가지고 있지 않다.**

비클러스터형 인덱스는 책 뒷장의 '찾아보기' 페이지와 닮아있다.

<br>

비클러스터형 인덱스는 테이블 당 **여러개 생성이 가능** 하다.

![image](https://github.com/lielocks/WIL/assets/107406265/f8f4f363-ad64-4337-9fef-f174aa1b8ca7)

앞서 말한 것처럼 비클러스터형 인덱스는 **인덱스 페이지와 데이터 페이지가 구분** 되어 있다.

루트 페이지는 클러스터형 인덱스와 비슷하게 인덱스에 대한 컬럼과 페이지 번호를 가지고 있다.

<br>

리프 페이지는 조금 다르다.

인덱스 컬럼을 가지고 있는 것은 비슷하지만, 데이터를 직접 가지고 있지 않으며 **`데이터 페이지 번호 + #오프셋`** 을 가지고 있어
**데이터 페이지의 특정행을 가르킨다.**

즉, 데이터에 접근하기 위해서는 **인덱스 페이지에서 데이터 페이지로 이동하는 하나의 과정이 추가**된다.

<br>

인덱스 페이지는 정렬되어 있지만, 실제 데이터 페이지는 정렬되어 있지 않으므로 
`클러스터형 인덱스에 비해 삽입, 수정, 삭제 작업이 비교적 빠르다.`

데이터 페이지에는 정렬 순서 상관 없이 빈 곳에 데이터를 삽입하면 되기 때문이다.

<br>

### 클러스터형 인덱스와 비클러스터형 인덱스의 혼합

현실적으로는 하나에 테이블에 클러스터형 인덱스와 비클러스터형 인덱스가 혼합되어 있는 경우가 많다. 

PK는 기본적으로 존재하고, 추가로 조회가 자주 발생하는 컬럼에 대해 인덱스를 추가하기 때문이다.

<br>

이런 경우에는 **비클러스터형 인덱스를 먼저 거치고, 이어 클러스터형 인덱스를 거쳐 데이터를 찾는다.**

이때, 비클러스터형 인덱스는 데이터 **`페이지 번호 + #오프셋`** 대신 **`클러스터형 인덱스에 대한 컬럼 값`** 을 갖는다.

![image](https://github.com/lielocks/WIL/assets/107406265/7f9dae5d-63fd-44dd-81e2-620e8539e7fe)

위 그림은 **`rank`** column 을 PK 로 지정하고,

추가로 **`language`** column 에 대해 비클러스터형 인덱스를 생성한 모습이다.

비클러스터형 인덱스의 인덱스 페이지는 **`language`** column 을 기준으로 잘 정렬되어 있다.

그리고 **`페이지 번호 + #오프셋`** 대신 **`rank`** column 값을 가지고 있는 것을 확인할 수 있다.

<br>

 이 **`rank`** 값을 가지고 클러스터형 인덱스에서 탐색을 하게 된다. 
 
 이후에는 우리가 알고있는 클러스터형 인덱스의 동작과정과 동일하게 데이터를 탐색한다.


<br>


그런데 왜 *비클러스터형 인덱스* 에서 *PK값* 을 가지고 있는 것일까? 

> 클러스터형 인덱스는 데이터를 직접 가지고 있고, 테이블 전체가 정렬된 인덱스라고 이야기했다. 
>
> 
> 테이블에 **데이터가 추가, 수정, 삭제 되면 테이블 데이터의 페이지 번호와 페이지 내 순서가 모두 변경된다.**

이런 구조에서 비클러스터형 인덱스가 **`페이지 번호 + #오프셋`** 정보를 직접 들고 있다면, 
**비클러스터형 인덱스를 모두 수정해야하는 치명적인 문제점**이 발생한다. 

> **따라서 이런 혼합 인덱스 구조에서는 비클러스터형 인덱스가 PK를 가지고 있는 것이다.**
