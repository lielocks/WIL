## OSI 7 계층이란?

OSI 7 계층은 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 말한다. 


<br>


### OSI 7 계층을 나눈이유는?

계층을 나눈 이유는 통신이 일어나는 과정을 단계별로 파악할 수 있기 때문이다.

흐름을 한눈에 알아보기 쉽고, 사람들이 이해하기 쉽고,

7단계 중 *특정한 곳* 에 이상이 생기면 다른 단계의 장비 및 소프트웨어를 건들이지 않고도 이상이 생긴 단계만 고칠 수 있기 때문이다.

(It is because of the fact that it will be **easy for troubleshooting the network problems.** 
Only the layer in which the problem exist will be modified. Other layers are left untouched.)


<br>


그럼 문제를 예로 들어보자

```
PC방에서 오버워치를 하는데 연결이 끊겼다.

어디에 문제가 있는지 확인하기 위해서는

모든 PC가 문제가 있다면
라우터의 문제(3계층 네트워크 계층)이거나 광랜을 제공하는 회사의 회선 문제(1계층 물리 계층)

한 PC만 문제가 있고  
오버워치 소프트웨어에 문제가 있다면(7계층 어플리케이션 계층)

오버워치 소프트웨어에 문제가 없고, 스위치에 문제가 있으면(2계층 데이터링크 계층)

있다고 판단해 다른 계층에 있는 장비나 소프트웨어를 건들이지 않는것이다.
```


<br>



## OSI 7 계층 단계

![image](https://github.com/lielocks/WIL/assets/107406265/c3cb4607-fd48-45e2-b2b4-60be448495ba)


<br>


### [ 1계층 - 물리계층(Physical Layer) ]

이 계층에서는 주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하게 된다.

이 계층에서 사용되는 통신 단위는 **bit** 이며 이것은 *1과 0* 으로 나타내어지는, 즉 전기적으로 *On, Off* 상태라고 생각하면 된다.

![image](https://github.com/lielocks/WIL/assets/107406265/f51a24d9-f328-40d8-934e-2c5f276d146f)


<br>


이 계층에서는 단지 데이터를 전달만 할 뿐 전송하려는(또는 받으려는) **데이터가 무엇인지, 어떤 에러가 있는지 등에는 전혀 신경쓰지 않는다.**

단지 데이터 **전기적인 신호로 변환해서 주고받는 기능만** 할 뿐이다.

이 계층에 속하는 대표적인 장비는 **`통신 케이블, 리피터, 허브`** 등이 있다.

> **-> 케이블, 리피터, 허브를 통해 데이터를 전송한다.**

![image](https://github.com/lielocks/WIL/assets/107406265/a0dcf77e-8c3b-4fd9-893e-ef4c8e914d20)

![image](https://github.com/lielocks/WIL/assets/107406265/74b177b7-bbd0-4c1d-9e81-7d50290d30b5)

<br>


### [ 2계층 - 데이터 링크계층(DataLink Layer) ]

![image](https://github.com/lielocks/WIL/assets/107406265/2f126fa1-5059-4181-a3fe-9abe0a997afb)

물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 **정보의 전달을 수행** 할 수 있도록 도와주는 역할을 한다.

따라서 통신에서의 오류도 찾아주고 재전송도 하는 기능을 가지고 있는 것이다.

이 계층에서는 **MAC 주소를 가지고 통신** 하게 된다.

이 계층에서 전송되는 단위를 **frame** 이라고 하고, 대표적인 장비로는 **`브리지, 스위치`** 등이 있다.
(여기서 **MAC 주소** 를 사용한다.)

> **-> 브릿지나 스위치를 통해 MAC 주소를 가지고 물리계층에서 받은 정보를 전달함.**

<div align='center'>
    <img src="https://github.com/lielocks/WIL/assets/107406265/b44beaa6-6787-4109-944f-5077ad83fed3" width="600" height="600"/>
    <img src="https://github.com/user-attachments/assets/7f51a46b-dd75-40a0-9448-1091e6cb7e2d" width="600" height="600"/>
</div>

<br>


데이터 링크 계층(Data Link Layer)은 **`포인트 투 포인트(Point to Point) 간 신뢰성있는 전송`** 을 보장하기 위한 계층으로

*CRC 기반의 오류 제어와 흐름 제어가 필요하다.*

네트워크 위의 개체들 간 데이터를 전달하고, 물리 계층에서 발생할 수 있는 오류를 찾아내고, 수정하는데 필요한 기능적, 절차적 수단을 제공한다.

주소 값은 물리적으로 할당받는데, 이는 **네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻이다.**


<br>


주소 체계는 계층이 없는 단일 구조이다.

DataLink 계층의 가장 잘 알려진 예는 **`Ethernet`** 이다.

> *리피터와 허브를 이용해 컴퓨터 여러대가 데이터를 보내면 데이터들이 서로 부딪히는데, 이를 충돌(Collision)* 이라고 합니다.
>
> 이런 충돌을 방지하기 위하여 여러 컴퓨터가 동시에 데이터를 전송해도 충돌이 일어나지 않는 구조로 되어있는 **이더넷(Ethernet)의 CSMA/CD** 을 사용했는데, 효율이 좋지 않아 현재는 사용하지 않습니다.
>
> 현재는 데이터 충돌을 방지하기 위하여 **스위치(Switch)** 를 사용합니다.
>
> **`CSMA/CD`** : Ethernet 이 충돌을 방지하기 위하여 데이터를 보내는 시점을 늦추는 것

이 외에도 `HDLC 나 ADCCP` 같은 **포인트 투 포인트(point-to-point) 프로토콜** 이나 **Packet Switching 네트워크** 나 `LLC, ALOHA` 같은 **근거리 네트워크용 프로토콜** 이 있다.

**`네트워크 브릿지나 스위치`** 등이 이 계층에서 동작하며, ***직접 이어진 곳에만*** 연결할 수 있다.


> **-> 프레임에 주소부여(MAC - 물리적주소) 에러검출/재전송/흐름제어**


<br>


+ **흐름 제어** : 송신 측과 수신 측의 속도 차이를 조정

+ **오류 제어** : 오류 검출과 회복

+ **순서 제어** : 프레임의 순서적 전송

+ **프레임 동기화** : 프레임의 시작과 끝을 구별하기 위한 동기화


<br>


![image](https://github.com/lielocks/WIL/assets/107406265/8fa168ce-4d4e-46af-a89f-25088e760fcc)



<br>



### [ 3계층 - 네트워크 계층(Network Layer) ]

![image](https://github.com/lielocks/WIL/assets/107406265/95d8ca8e-5cd1-43b8-8c85-4b1436969084)

이 계층에서 가장 중요한 기능은 **데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능`(routing)`** 이다.

여기에 사용되는 프로토콜의 종류도 다양하고, **routing** 하는 기술도 다양하다.


<br>


이 계층은 **최적의 경로를 선택하고 주소를 정하고 경로에 따라 packet 을 전달해주는 것** 이 이 계층의 역할이다. 

![image](https://github.com/lielocks/WIL/assets/107406265/5562e7bb-4e26-4c5f-a765-6bd0dbbc2a9c)


이 계층의 대표적인 장비는 **`Router`** 이며, 요즘은 `2계층의 장비 중 swtich 라는 장비에 routing 기능을 장착한` *Layer 3 switch` 도 있다.

(여기서 **IP 주소** 를 사용한다.)



<br>


**Router** 가 이 계층에서 동작하고 *이 계층에서 동작하는 스위치* 도 있다. 

데이터를 연결하는 다른 네트워크를 통해 전달함으로써 *인터넷* 이 가능하게 만드는 계층이다. 

**논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, `계층적(hierarchical)`** 이다.


<br>


서브네트의 최상위 계층으로 경로를 설정하고, 청구 정보를 관리한다. 

개방형 시스템들의 사이에서 네트워크 연결을 설정, 유지, 해제하는 기능을 부여하고, 전송 계층 사이에 `네트워크 서비스 데이터 유닛(NSDU : Network Service Data Unit)` 을 교환하는 기능을 제공한다.

> **-> 주소부여(IP), 경로설정(Route)**


<br>


### 네트워크 계층 - IP 계층

TCP / IP 상에서 **`IP 계층`** 이란 

네트워크의 주소(IP 주소) 를 정의하고, **IP packet 의 전달 및 Routing 을 담당하는 계층**


<br> 


OSI 7 계층 모델의 관점에서 보면 **IP 계층은 네트워크 계층** 에 해당

== 즉, packet 을 목적지까지 전달하는 역할 및 그에 수반되는 기타 역할을 함


<br>


**IP 계층의 주요 역할**

== IP 계층에서는 그 하위계층인 DataLink Layer 의 hardware 적인 특성에(즉, ATM 이던 Frame Relay 이던 상관없이) 관계없이 **독립적인** 역할을 수행


<br>


**IP 계층 상에 있는 주요 프로토콜**

+ **`packet 의 전달`** 을 책임지는 IP

+ packet 전달 에러의 보고 및 진단을 위한 ICMP

+ 복잡한 네트워크에서 *인터네트워킹을 위한 경로* 를 찾게 해주는 **라우팅** 프로토콜


<br>



### 네트워크 계층 - IP 프로토콜

*TCP / IP 기반의 인터넷 망* 을 통하여 **데이터그램의 전달을 담당하는 프로토콜**


<br>


**1. 주요 기능**

IP 계층에서 **IP packet 의 `라우팅 대상` 이 됨** (Routing)

**IP 주소 지정** (Addressing)


<br>



**2. 주요 특징**

+ 신뢰성(error 제어) 및 흐름 제어 기능이 전혀 없음 -> Best-Effort Service
  
  + 한편, 신뢰성을 확보하려면 IP 계층 위의 *TCP 와 같은 상위 Transport 계층에 의존*

+ **`비연결성 데이터그램 방식`** 으로 전달되는 프로토콜 **Connectionless**

+ packet 의 완전한 전달(소실, 중복, 지연, 순서바뀜 등이 없게 함)을 보장하지 않음 **Unreliable**

+ **`IP packet header`** 내 **수신 및 발신 주소** 를 포함 `IPv4 헤더, IPv6 헤더, IP 주소`

+ IP packet 내 바이트 전달 순서 : 최상위 바이트(MSB) 를 먼저 보냄 -> Big-endian

+ 경우에 따라 단편화가 필요함 (IP 단편화 참고)

+ TCP, UDP, ICMP, IGMP 등이 IP 데이터그램에 실려서 전송


<br>



### [ 4계층 - 전송 계층(Transport Layer) ]

통신을 활성화하기 위한 계층이다. 

보통 **`TCP 프로토콜`** 을 이용하며, **port 를 열어서 응용프로그램들이 전송** 을 할 수 있게 한다. 

만약 데이터가 왔다면 *4계층에서 해당 데이터를 하나로 합쳐서 5계층에 던져 준다.* 

단대단 오류제어 및 흐름제어 이 계층 까지는 물리적인 계층에 속한다. (TCP / UDP 프로토콜을 사용한다.)


<br>


전송 계층(Transport layer) 은 **양 끝단(End to end) 의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록** 해 주어, 

*상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.* 

`Sequence number 기반` 의 오류 제어 방식을 사용한다. 

전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 **상태 개념** 이 있고(stateful), **연결 기반(connection oriented)** 이다. 

이는 **`전송 계층이 패킷들의 전송이 유효한지 확인`** 하고 **`전송 실패한 패킷들을 다시 전송한다`** 는 것을 뜻한다. 

가장 잘 알려진 전송 계층의 예는 TCP 이다.


<br>


**`종단간(end-to-end) 통신을 다루는 최하위 계층`** 으로 종단간 신뢰성 있고 효율적인 데이터를 전송하며, 기능은 **오류검출 및 복구와 흐름제어, 중복검사** 등을 수행한다.

> **-> 패킷 생성(Assembly/Sequencing/Deassembly/Error detection/Request repeat/Flow control) 및 전송**


<br>


### 전송 계층 - TCP 프로토콜(Transmission Control Protocol)

OSI 계층 모델의 관점에서 전송 계층(4계층)에 해당

양종단 호스트 내 process 상호 간에 신뢰적인 연결지향성 서비스를 제공

== IP 의 비신뢰적인 최선형 서비스에다가 신뢰적인 연결지향성 서비스를 제공하게 됨

== **신뢰적인 전송을 보장** 함으로써, 어플리케이션 구현이 한층 쉬워지게 됨


<br>


**1. 신뢰성 있음 (Reliable)**

packet 손실, 중복, 순서 바뀜 등이 없도록 보장

TCP 하위계층인 IP 계층의 신뢰성 없는 서비스에 대해 다방면으로 신뢰성을 제공


<br>


**2. 연결지향적 (Connection-oriented) -> TCP 연결** 

같은 전송계층의 UDP 가 비연결성(connectionless)인 것과는 달리, TCP 는 **연결지향적** 이다

이 경우, 느슨한 연결(Loosly Connected) 을 갖으므로 *강한 연결을 의미하는 가상회선이라는 표현* 보다는 오히려 **연결지향적** 이라고 말함

연결 관리를 위한 *연결설정 및 연결해제* 필요 (TCP 연결설정, TCP 연결종료)

**`양단간 어플리케이션/프로세스`** 는 **TCP 가 제공하는 연결성 회선을 통하여 서로 통신**


<br>


### 전송 계층 - UDP 프로토콜(User Datagram Protocol)

전송 계층의 통신 프로토콜의 하나 (TCP 에 대비됨)

== **신뢰성이 낮은 프로토콜** 로써 완전성을 보증하지 않으나

== 가상회선을 굳이 확립할 필요가 없고 유연하며 효율적 응용의 데이터 전송에 사용


**1. 비연결성이고, 신뢰성이 없고, 순서화되지 않은 Datagram 서비스 제공**

+ 메세지가 제대로 도착했는지 확인하지 않음 `(확인응답 없음)`

+ 수신된 메세지의 순서를 맞추지 않음 `(순서제어 없음)` 

+ 흐름 제어를 위한 피드백을 제공하지 않음 `(흐름제어 없음)`

+ 검사합을 제외한 특별한 오류 검출 및 제어 없음 `(오류제어 거의 없음)`

  + UDP를 사용하는 프로그램 쪽에서 오류제어 기능을 스스로 갖추어야 함

+ **데이터그램 지향** 의 전송 계층용 프로토콜 `(논리적인 가상회선 연결이 필요없음)`

  + **`비연결 접속상태`** 하에서 통신


<br>


**2. 실시간 응용 및 `Multicasting` 가능**

+ 빠른 요청과 응답이 필요한 **실시간 응용** 에 적합

+ **`여러 다수 지점`** 에 전송 가능 (1:多)


<br>



**3. header 가 단순함**

+ UDP 가 TCP 처럼 16 bit 의 port 번호를 사용하나, header 는 고정 크기의 8 bytes(TCP 는 20 bytes) 만 사용

![image](https://github.com/lielocks/WIL/assets/107406265/68c5402f-aa9d-48a4-a6d2-a4e54c2c21dc)


+ 즉 *header 처리* 에 많은 시간과 노력을 요하지 않음


<br>


### [5계층 - 세션 계층(Session Layer) ]

**데이터가 통신하기 위한 논리적인 연결** 을 말한다.

통신을 하기위한 대문이라고 보면 된다. 

하지만 4계층에서도 연결을 맺고 종료할 수 있기 때문에 우리가 어느 계층에서 통신이 끊어졌나 판단하기는 한계가 있다. 

그러므로 Session 계층은 4계층과 무관하게 **응용 프로그램 관점** 에서 봐야 한다. 

**Session 설정, 유지, 종료, 전송 중단시 복구** 등의 기능이 있다.


<br>


세션 계층(Session layer) 은 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다. 

**`동시 송수신 방식(duplex)`** , **`반이중 방식(half-duplex)`** , **`전이중 방식(Full Duplex)`** 의 통신과 함께 `체크 포인팅과 유휴, 종료, 다시 시작 과정` 등을 수행한다. 

이 계층은 **TCP / IP session 을 만들고 없애는 책임** 을 진다.


<br>


> **통신하는 사용자들을 동기화하고 오류복구 명령들을 일괄적으로 다룬다.**
> 
> **통신을 하기 위한 세션을 확립/유지/중단 (운영체제가 해줌)**


<br>


### [ 6계층 - 표현 계층(Presentation Layer) ]

*데이터 표현이 상이한 응용 프로세스* 의 **독립성을 제공** 하고 **암호화** 한다.

**`표현 계층(Presentation layer)`** 은 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다. 

**MIME 인코딩** 이나 **암호화** 등의 동작이 이 계층에서 이루어진다. 

예를 들면, **`EBCDIC 로 인코딩된 문서 파일`** 을 **`ASCII 로 인코딩된 파일`** 로 바꿔 주는 것,

해당 데이터가 `TEXT` 인지, `그림` 인지, `GIF` 인지 `JPG` 인지의 **구분** 등이 표현 계층의 몫이다.

> **-> 사용자의 명령어를 완성및 결과 표현.** 포장 / 압축 / 암호화


<br>



### [ 7계층 - 응용 계층(Application Layer) ] 

![image](https://github.com/lielocks/WIL/assets/107406265/c2b814d2-0525-418c-8ba7-0072ab34fbc8)


**최종 목적지** 로서 `HTTP, FTP, SMTP, POP3, IMAP, Telnet` 등과 같은 프로토콜이 있다.

해당 통신 packet 들은 방금 나열한 프로토콜에 의해 모두 처리되며 우리가 사용하는 브라우저나, 메일 프로그램은 프로토콜을 보다 쉽게 사용하게 해주는 응용 프로그램이다.

한마디로 모든 통신의 양 끝단은 **HTTP 와 같은 프로토콜** 이지 *응용 프로그램이 아니다.*

**응용 계층(Application layer)** 은 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다. 

일반적인 응용 서비스는 **관련된 응용 프로세스들 사이의 `전환`** 을 제공한다. 

응용 서비스의 예로 *가상 터미널(예를 들어 telnet)* , "Job Transfer and Manipulation protocol" (JTM, 표준 ISO/IEC 8832) 등이 있다.

> **네트워크 소프트웨어 UI 부분, 사용자의 입출력(I/O) 부분**


<br>


### 응용 계층 - HTTP 프로토콜(HyperText Transfer Protocol)

Web 상에서 **Web Server 및 Web Browser 상호 간의 데이터 전송** 을 위한 응용 계층 프로토콜

처음에는 *WWW 상의 HyperText 형태의 문서를 전달* 하는데 주로 이용

현재에는 image, video, 음성 등 거의 **모든 형식의 데이터** 전송 가능


<br>


**1. 요청 및 응답의 구조**

동작 형태가 **`client / server 모델`** 로 동작


<br>


**2. 메세지 교환 형태의 프로토콜**

+ Client 와 Server 간에 'HTTP 메세지' 를 주고받으며 통신 SMTP 전자메일 프로토콜과 유사

+ HTTP 의 응답 및 요청 메세지 구성

+ HTTP 메세지 내 header 항목들


<br>


**3. Transaction 중심의 비연결성 프로토콜**

+ 종단간 연결이 없음 **Connectionless**

+ 이전의 상태를 유지하지 않음 **Stateless**


<br>


**4. 전송계층 프로토콜 및 사용 port 번호**

+ 전송계층 프로토콜 : TCP

+ 사용 포트 번호 : 80번


<br>



**5. HTTP 표준**

**`HTTP 1.0`** : *RFC 1945* (~1997년) 

- 유용한 초기 개념들 도입

- HTTP header, HTTP method, HTTP status code, Redirect, 비지속 연결 등


<br>


**`HTTP 1.1`** : *RFC 2068 => RFC 2616 => RFC 7230~7235* (1998년~) 

- HTTP 1.0 으로부터 기능 향상

- HTTP header 내 **Host field** 를 필수 항목으로 함 *(1개 IP 주소에 다수의 가상 호스팅 가능)*

- HTTP header 내 Accept field 에 의한 컨텐츠 협상

- 잘 정의된 **Cache Control**

- Block 단위 encoding 전송

- **`지속 연결 회선(Keep Alive Connection)`** 을 통한 **재사용** 가능

- 요청 Pipeline 을 이용한 **병렬 connection 처리** (실제 사용 거의 없음) 등
